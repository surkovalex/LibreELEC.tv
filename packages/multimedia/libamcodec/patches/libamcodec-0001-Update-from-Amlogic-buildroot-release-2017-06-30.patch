From e82413f8e16f90e40852410c857b8c082b0ad580 Mon Sep 17 00:00:00 2001
From: alex <surkov.alex@gmail.com>
Date: Sat, 8 Jul 2017 21:47:14 +0300
Subject: [PATCH] Update from Amlogic buildroot release 2017-06-30

---
 amadec/Makefile                     |  14 +-
 amadec/adec-external-ctrl.c         |  76 ++++
 amadec/adec-ffmpeg-mgt.c            | 337 +++++++++++++--
 amadec/adec-internal-mgt.c          |  13 +-
 amadec/adec-message.h               |  10 +-
 amadec/adec-pts-mgt.c               |  56 ++-
 amadec/adec-pts-mgt.h               |   1 +
 amadec/adec_read.c                  |  10 +-
 amadec/adec_write.h                 |   2 +
 amadec/audio-dec.h                  |  33 +-
 amadec/audio_out/alsa-out-raw.c     | 842 ++++++++++++++++++++++++++++++++++++
 amadec/audio_out/alsa-out-raw.h     |  19 +
 amadec/audio_out/alsa-out.c         | 186 +++++++-
 amadec/audio_out/android-out.cpp    |  46 +-
 amadec/audiodsp_update_format.c     |  13 +-
 amadec/include/adec-external-ctrl.h |   2 +
 amadec/include/adec-types.h         |   1 +
 amadec/include/alsa-out.h           |   2 +
 amadec/include/log-print.h          |   4 +-
 amavutils/Makefile                  |   8 +-
 amavutils/amdrmutils.c              | 152 +++++++
 amavutils/amsysfsutils.c            |  14 +-
 amavutils/include/amdrmutils.h      |  27 ++
 amcodec/audio_ctl/audio_ctrl.c      |  39 ++
 amcodec/codec/codec_ctrl.c          | 262 ++++++-----
 amcodec/codec/codec_h_ctrl.c        | 408 ++++++++++++++++-
 amcodec/codec/codec_h_ctrl.h        |   3 +-
 amcodec/include/amports/aformat.h   |  45 +-
 amcodec/include/amports/amstream.h  | 384 ++++++++++++----
 amcodec/include/amports/vformat.h   |  13 +-
 amcodec/include/codec.h             |  11 +-
 amcodec/include/codec_type.h        |   3 +
 32 files changed, 2723 insertions(+), 313 deletions(-)
 create mode 100644 amadec/audio_out/alsa-out-raw.c
 create mode 100644 amadec/audio_out/alsa-out-raw.h
 create mode 100644 amavutils/amdrmutils.c
 create mode 100644 amavutils/include/amdrmutils.h

diff --git a/amadec/Makefile b/amadec/Makefile
index 4728ed3..a88f654 100644
--- a/amadec/Makefile
+++ b/amadec/Makefile
@@ -3,7 +3,8 @@ M_PREFIX=$(PREFIX)
 TARGET=libamadec.so
 
 TARGET_OBJS=adec-external-ctrl.o adec-internal-mgt.o adec-ffmpeg-mgt.o adec-message.o adec-pts-mgt.o feeder.o adec_write.o adec_read.o\
-           dsp/audiodsp-ctl.o audio_out/alsa-out.o audio_out/aml_resample.o audiodsp_update_format.o spdif_api.o pcmenc_api.o dts_transenc_api.o dts_enc.o audio_out/alsactl_parser.o 
+            dsp/audiodsp-ctl.o audio_out/alsa-out.o audio_out/aml_resample.o audiodsp_update_format.o spdif_api.o pcmenc_api.o \
+           dts_transenc_api.o dts_enc.o audio_out/alsactl_parser.o audio_out/alsa-out-raw.o
 
 INSTALL_DIR=${M_PREFIX}/lib
 
@@ -11,14 +12,19 @@ LDFLAGS += -shared -lpthread -lm -lasound -lrt -ldl -lamavutils
 
 CFLAGS+=-O2 -fPIC
 CFLAGS+=-I$(shell pwd) -I$(shell pwd)/include -I$(shell pwd)/../amavutils/include -I${PREFIX}/include -I${PREFIX}/usr/include -L${PREFIX}/lib -L${PREFIX}/usr/lib
-CFLAGS+=-DALSA_OUT -DENABLE_WAIT_FORMAT
+CFLAGS+=-DALSA_OUT
+
+ifdef DOLBY_UDC
+    CFLAGS+=-DDOLBY_USE_ARMDEC
+endif
+
 
 export CC CFLAGS
 
-all: $(TARGET) 
+all: $(TARGET)
 
 $(TARGET): $(TARGET_OBJS)
-	$(CC) $(CFLAGS) $(TARGET_OBJS:%.o=%.c) $(LDFLAGS) -o $@  
+	$(CC) $(CFLAGS) $(TARGET_OBJS:%.o=%.c) $(LDFLAGS) -o $@
 
 install:$(TARGET)
 	-install -m 555 ${TARGET} $(INSTALL_DIR)
diff --git a/amadec/adec-external-ctrl.c b/amadec/adec-external-ctrl.c
index ffe86b1..b8bdb98 100755
--- a/amadec/adec-external-ctrl.c
+++ b/amadec/adec-external-ctrl.c
@@ -59,6 +59,7 @@ int audio_decode_init(void **handle, arm_audio_info *a_ainfo)
 	audec->bitrate=a_ainfo->bitrate;
 	audec->block_align=a_ainfo->block_align;
 	audec->codec_id=a_ainfo->codec_id;
+    audec->auto_mute=a_ainfo->automute;
 	if (a_ainfo->droppcm_flag) {
 		audec->droppcm_flag = a_ainfo->droppcm_flag;
 		a_ainfo->droppcm_flag = 0;
@@ -67,6 +68,10 @@ int audio_decode_init(void **handle, arm_audio_info *a_ainfo)
         memcpy((char*)audec->extradata,(char*)a_ainfo->extradata,a_ainfo->extradata_size);
     audec->adsp_ops.audec=(void *)audec;    
 //	adec_print("audio_decode_init  pcodec = %d, pcodec->ctxCodec = %d!\n", pcodec, pcodec->ctxCodec);
+    audec->volume_ease_start = 1.0;
+    audec->volume_ease_cur = 1.0;
+    audec->volume_ease_end = 1.0;
+    
     ret = audiodec_init(audec);
     if (ret) {
         adec_print("adec init failed!");
@@ -385,6 +390,46 @@ int audio_decode_set_lrvolume(void *handle, float lvol,float rvol)
  * \brief set audio volume
  * \param handle pointer to player private data
  * \param vol volume value
+ * \param duration volume ease duration in millisecond
+ * \param method volume ease method
+ * \return 0 on success otherwise -1 if an error occurred
+ */
+int audio_decode_set_volume_ease(void *handle, float vol, unsigned int duration, int method)
+{
+    int ret;
+    adec_cmd_t *cmd;
+    aml_audio_dec_t *audec = (aml_audio_dec_t *)handle;
+
+    if (!handle) {
+        adec_print("audio handle is NULL !\n");
+        return -1;
+    }
+
+    if ((method < 0) || (method > 2)) {
+        adec_print("invalid volume ease method !\n");
+        return -1;
+    }
+
+    cmd = adec_message_alloc();
+    if (cmd) {
+        cmd->ctrl_cmd = CMD_SET_VOL_EASE;
+        cmd->value.volume = vol;
+        cmd->value_ext.en = method;
+        cmd->value_ext2 = duration;
+        cmd->has_arg = 1;
+        ret = adec_send_message(audec, cmd);
+    } else {
+        adec_print("message alloc failed, no memory!");
+        ret = -1;
+    }
+
+    return ret;
+}
+
+/**
+ * \brief set audio volume
+ * \param handle pointer to player private data
+ * \param vol volume value
  * \return 0 on success otherwise -1 if an error occurred
  */
 int audio_decode_get_volume(void *handle, float *vol)
@@ -427,6 +472,37 @@ int audio_decode_get_lrvolume(void *handle, float *lvol,float* rvol)
 }
 
 /**
+ * \brief set audio volume
+ * \param handle pointer to player private data
+ * \param vol: current vulume
+ * \param duration: remaining duration for ease target volume
+ * \return 0 on success otherwise -1 if an error occurred
+ */
+int audio_decode_get_volume_ease(void *handle, float *vol, unsigned int *duration)
+{
+    int ret = 0;
+    adec_cmd_t *cmd;
+    aml_audio_dec_t *audec = (aml_audio_dec_t *)handle;
+
+    if (!handle) {
+        adec_print("audio handle is NULL !\n");
+        return -1;
+    }
+
+    adec_print("audio_decode_get_volume_ease %f\n", audec->volume_ease_cur);
+    *vol = audec->volume_ease_cur;
+    if (audec->volume_ease_update) {
+        *duration = audec->volume_ease_duration_staging;
+    } else {
+        *duration = audec->volume_ease_duration_staging - audec->volume_ease_sample * 1000 / audec->samplerate;
+    }
+
+    return ret;
+}
+
+
+
+/**
  * \brief swap audio left and right channels
  * \param handle pointer to player private data
  * \return 0 on success otherwise -1 if an error occurred
diff --git a/amadec/adec-ffmpeg-mgt.c b/amadec/adec-ffmpeg-mgt.c
index e37e112..99468f2 100755
--- a/amadec/adec-ffmpeg-mgt.c
+++ b/amadec/adec-ffmpeg-mgt.c
@@ -1,6 +1,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <math.h>
 #include <fcntl.h>
 #include <pthread.h>
 #include <sys/ioctl.h>
@@ -13,7 +14,7 @@
 #include <audio-dec.h>
 
 
-
+#define HEADER_LENGTH_AFTER_IEC61937 0x4
 
 
 
@@ -52,24 +53,27 @@ audio_lib_t audio_lib_list[] =
     {ACODEC_FMT_ALAW,"libpcm.so"},
     {ACODEC_FMT_MULAW,"libpcm.so"},
     {ACODEC_FMT_ADPCM,"libadpcm.so"},
-    NULL
+    {ACODEC_FMT_AC3,"libeac3.so"},
+    {ACODEC_FMT_EAC3,"libeac3.so"}
 } ;
 
 int find_audio_lib(aml_audio_dec_t *audec)
-{    
+{
     int i;
     int num;
     audio_lib_t *f;
-    int fd = 0;
+    void *fd = NULL;
     adec_print("[%s %d]audec->format/%d audec->codec_id/0x%x\n",__FUNCTION__,__LINE__,audec->format,audec->codec_id);
-    num = ARRAY_SIZE(audio_lib_list);   
+    num = ARRAY_SIZE(audio_lib_list);
     audio_decoder_operations_t *adec_ops=audec->adec_ops;
     //-------------------------
     //if(find_omx_lib(audec))
     //    return 0;
     //-----------------------
     for (i = 0; i < num; i++) {        
-        f = &audio_lib_list[i];        
+        f = &audio_lib_list[i];
+        adec_print("[%s::%d]--[f->codec_id:%d]\n",__FUNCTION__, __LINE__, f->codec_id);
+
         if (f->codec_id == audec->format) 
         {            
             fd = dlopen(audio_lib_list[i].name,RTLD_NOW);
@@ -79,12 +83,19 @@ int find_audio_lib(aml_audio_dec_t *audec)
                 adec_ops->decode  = dlsym(fd, "audio_dec_decode");
                 adec_ops->release = dlsym(fd, "audio_dec_release");
                 adec_ops->getinfo = dlsym(fd, "audio_dec_getinfo");
+                adec_print("[%s::%d]--[audio_lib_list[i].name:%s] found it!\n",__FUNCTION__, __LINE__, audio_lib_list[i].name);
             }else{
-                adec_print("cant find decoder lib\n");
+                char const *err_str = dlerror();
+                adec_print("[%s::%d]--[module=%s\n%s",__FUNCTION__, audio_lib_list[i].name, err_str ? err_str : "unknown");
+                adec_print("the so appear bad file, can not find decoder lib!!\n");
                 return -1;
             }           
             return 0;
         }
+        else {
+            adec_print("[%s::%d]--[f->codec_id:%d]--not~fit-[audio_lib_list[i].name:%s]\n",
+                __FUNCTION__, __LINE__, f->codec_id, audio_lib_list[i].name);
+        }
     }    
     return -1;
 }
@@ -197,25 +208,116 @@ struct package * package_get(aml_audio_dec_t * audec)
     return p;
 }
 
+static inline float EaseNext(int method, float t, float b, float c, float d)
+{
+    switch (method) {
+    default:
+    case 0:
+        return c*t/d + b;
+    case 1:
+        t/=d;
+        return c*t*t*t + b;
+    case 2:
+        t=t/d-1;
+        return c*(t*t*t + 1) + b;
+    }
+}
+
+static void armdec_stream_ease(aml_audio_dec_t *audec, char *buf, int size)
+{
+    int i;
+    float delta;
+    short *p = (short *)buf;
+    float delta_vol;
+    unsigned int delta_dur;
+
+    if (audec->volume_ease_update) {
+        audec->volume_ease_start = audec->volume_ease_cur;
+        if (audec->volume_ease_duration_staging == 0) {
+            audec->volume_ease_cur = audec->volume_ease_end_staging;
+        }
+        audec->volume_ease_end = audec->volume_ease_end_staging;
+        audec->volume_ease_method = audec->volume_ease_method_staging;
+        audec->volume_ease_duration = audec->volume_ease_duration_staging;
+        audec->volume_ease_sample = 0;
+        audec->volume_ease_update = 0;
+#if 0
+        adec_print("armdec_stream_ease : %f, %f->%f, dur %d, method %d, delta_dur = %d, sr=%d",
+                    audec->volume_ease_start, audec->volume_ease_cur, audec->volume_ease_end,
+                    audec->volume_ease_duration, audec->volume_ease_method,
+                    audec->volume_ease_duration * audec->samplerate / 1000, audec->samplerate);
+#endif
+    }
+
+    delta_vol = audec->volume_ease_end - audec->volume_ease_start;
+    delta_dur = audec->volume_ease_duration * audec->samplerate / 1000;
+
+    if (audec->volume_ease_sample >= delta_dur) {
+        if (audec->volume_ease_cur != 1.0) {
+            float c = audec->volume_ease_cur;
+            for (i=0; i<size/2; i++, p++) *p *= c;
+        }
+        return;
+    }
+
+    // ease volume
+    while ((char *)p < (buf+size)) {
+        if (audec->volume_ease_sample < delta_dur) {
+            float s = audec->volume_ease_cur;
+            audec->volume_ease_cur = EaseNext(audec->volume_ease_method,
+                                              (float)audec->volume_ease_sample,
+                                              audec->volume_ease_start,
+                                              delta_vol,
+                                              (float)delta_dur);
+#if 0
+            if (floor(s * 10) != floor(audec->volume_ease_cur * 10)) {
+                adec_print("easing: volume_ease_cur = %f\n", audec->volume_ease_cur);
+            }
+#endif
+            audec->volume_ease_sample++;
+#if 0
+            if (audec->volume_ease_sample == delta_dur) {
+                adec_print("ease done, volume_ease_cur = %f, volume_ease_sample=%d!\n", audec->volume_ease_cur, audec->volume_ease_sample);
+            }
+#endif
+        } else {
+            audec->volume_ease_cur = audec->volume_ease_end;
+        }
+
+        *p *= audec->volume_ease_cur;
+        p++;
+        if (audec->channels > 1) {
+            *p *= audec->volume_ease_cur;
+            p++;
+        }
+    }
+}
 
 int armdec_stream_read(dsp_operations_t *dsp_ops, char *buffer, int size)
 {   
      int read_size=0;
      aml_audio_dec_t *audec=(aml_audio_dec_t *)dsp_ops->audec;
      read_size=read_pcm_buffer(buffer,audec->g_bst, size);
+     if (read_size > 0)
+         armdec_stream_ease(audec, buffer, read_size);
      audec->out_len_after_last_valid_pts+=read_size;
      return read_size;
 }
 
 int armdec_stream_read_raw(dsp_operations_t *dsp_ops, char *buffer, int size)
 {
+     int read_size=0;
      aml_audio_dec_t *audec=(aml_audio_dec_t *)dsp_ops->audec;
-     return read_pcm_buffer(buffer,audec->g_bst_raw, size);
+     read_size = read_pcm_buffer(buffer,audec->g_bst_raw, size);
+     if ((read_size > 0) && (audec->volume_ease_cur == 0.0)) {
+         memset(buffer, 0, read_size);
+     }
+     return read_size;
 }
 unsigned long  armdec_get_pts(dsp_operations_t *dsp_ops)
 {
     unsigned long val,offset;
-    unsigned long pts;
+    unsigned long pts, pts_from_sample;
     int data_width,channels,samplerate;
     unsigned long long frame_nums ;
     unsigned long delay_pts;
@@ -236,11 +338,19 @@ unsigned long  armdec_get_pts(dsp_operations_t *dsp_ops)
     }
     channels=audec->g_bst->channels;
     samplerate=audec->g_bst->samplerate;
+    if(!channels || !samplerate){
+		adec_print("warning ::::zero  channels %d, sample rate %d \n",channels,samplerate);
+		if(!samplerate)
+			samplerate = 48000;
+		if(!channels)
+			channels = 2;
+    }
     offset=audec->decode_offset;
 
     if(dsp_ops->dsp_file_fd>=0){
         if(audec->g_bst->format != ACODEC_FMT_COOK && audec->g_bst->format != ACODEC_FMT_RAAC)
             ioctl(dsp_ops->dsp_file_fd,AMSTREAM_IOC_APTS_LOOKUP,&offset);
+//adec_print("lookup %d --> pts: %d", audec->decode_offset, offset/90);
     }else{
         adec_print("====abuf have not open!\n",val);
     }
@@ -248,14 +358,17 @@ unsigned long  armdec_get_pts(dsp_operations_t *dsp_ops)
        offset=0;
 
     pts=offset;
-    if(pts==0){
+    pts_from_sample = pts;
+
+    //if(pts==0){
         if (audec->last_valid_pts)
-           pts = audec->last_valid_pts;
+           pts_from_sample = audec->last_valid_pts;
         frame_nums = (audec->out_len_after_last_valid_pts * 8 / (data_width * channels));
-        pts+= (frame_nums*90000/samplerate);
+        pts_from_sample+= (frame_nums*90000/samplerate);
         //adec_print("decode_offset:%d out_pcm:%d   pts:%d \n",decode_offset,out_len_after_last_valid_pts,pts);
-        return pts; 
-    }
+        //return pts;
+    //}
+
 
     int len = audec->g_bst->buf_level+audec->pcm_cache_size;
     frame_nums = (len * 8 / (data_width * channels));
@@ -266,9 +379,35 @@ unsigned long  armdec_get_pts(dsp_operations_t *dsp_ops)
         pts = 0;
     }
     val=pts;
+
+    // pts_from_sample: pts calculated from last looked up pts + sample number accumulation (no gap)
+    // val: pts from lookup directly
+    // check netflix audio gap here, between 500-2000ms, then audio gap exist
+    //adec_print("pts_from_sample = %d, pts_from_lookup=%d, delay_pts = %d",
+    //            pts_from_sample/90, val/90, delay_pts/90);
+    if ((audec->gap_end_pts == 0) &&
+        ((int)(val - pts_from_sample) > 500 * 90) &&
+        ((int)(val - pts_from_sample) < 2000 * 90)) {
+        audec->gap_end_pts = pts_from_sample + delay_pts;
+        adec_print("gap_end_pts = %d, pts_from_sample = %d, pts_from_lookup=%d, delay_pts = %d",
+                    audec->gap_end_pts/90, pts_from_sample/90, val/90, delay_pts/90);
+    }
+
+    if ((audec->gap_end_pts) &&
+        ((int)(pts_from_sample - audec->gap_end_pts) < 0)) {
+        adec_print("use pts_from_sample %d during gap", pts_from_sample/90);
+        return pts_from_sample;
+    }
+
+    audec->gap_end_pts = 0;
+
+    if (pts==0) {
+        return pts_from_sample;
+    }
+
     audec->last_valid_pts=pts;
     audec->out_len_after_last_valid_pts=0;
-    //adec_print("====get pts:%ld offset:%ld frame_num:%lld delay:%ld \n",val,decode_offset,frame_nums,delay_pts);
+    //adec_print("[%s::%d]--[pts:%ld]--[offset:%ld]--[frame_num:%lld]--[delay_pts:%ld]\n", __FUNCTION__, __LINE__,pts,offset,frame_nums,delay_pts);
     return val;
 }
 
@@ -282,7 +421,8 @@ unsigned long  armdec_get_pcrscr(dsp_operations_t *dsp_ops)
     ioctl(dsp_ops->dsp_file_fd, AMSTREAM_IOC_PCRSCR, &val);
     return val;
 }
-unsigned long  armdec_set_pts(dsp_operations_t *dsp_ops,unsigned long apts)
+
+int  armdec_set_pts(dsp_operations_t *dsp_ops,unsigned long apts)
 {
     if (dsp_ops->dsp_file_fd < 0) {
         adec_print("armdec_set_apts err!\n");
@@ -455,6 +595,7 @@ static int audio_codec_init(aml_audio_dec_t *audec)
       audec->nDecodeErrCount=0;
       audec->g_bst=NULL;
       audec->g_bst_raw=NULL;
+      audec->gap_end_pts = 0;
       audec->fd_uio=-1;
       audec->last_valid_pts=0;
       audec->out_len_after_last_valid_pts=0;
@@ -643,7 +784,7 @@ static int get_first_apts_flag(dsp_operations_t *dsp_ops)
  * \brief start audio dec when receive START command.
  * \param audec pointer to audec
  */
-static void start_adec(aml_audio_dec_t *audec)
+static int start_adec(aml_audio_dec_t *audec)
 {
     int ret;
     audio_out_operations_t *aout_ops = &audec->aout_ops;
@@ -661,7 +802,7 @@ static void start_adec(aml_audio_dec_t *audec)
          {
              adec_print("wait first pts checkin complete !");
              times++;
-             if (times>=5) 
+             if (times>=50) 
              {
                  amsysfs_get_sysfs_str(TSYNC_VPTS, buf, sizeof(buf));// read vpts
                  if (sscanf(buf, "0x%lx", &vpts) < 1) {
@@ -677,8 +818,11 @@ static void start_adec(aml_audio_dec_t *audec)
              usleep(100000);
          }
         
+         adec_print("wait first pts checkin finish, time waited %d ms! auto_mute = %d\n", times/10, audec->auto_mute);
+
          /*start  the  the pts scr,...*/
          ret = adec_pts_start(audec);
+
          if (audec->auto_mute) {
              avsync_en(0);
              adec_pts_pause();
@@ -686,10 +830,13 @@ static void start_adec(aml_audio_dec_t *audec)
                 usleep(1000);
              }
              avsync_en(1);
-             adec_pts_resume();
+             //adec_pts_resume();
              audec->auto_mute = 0;
          }
          aout_ops->start(audec);
+         //audec->state = ACTIVE;
+
+         audec->state = PAUSED;
     }
 }
 
@@ -789,6 +936,24 @@ static void adec_set_lrvolume(aml_audio_dec_t *audec, float lvol,float rvol)
         aout_ops->set_lrvolume(audec, lvol,rvol);
     }
 }
+
+/**
+ * \brief set volume ease to audio dec when receive SET_VOL_EASE command.
+ * \param audec pointer to audec
+ * \param vol volume value
+ * \param duration duration to reach target volume in millisecond
+ * \param method ease method
+ */
+static void adec_set_volume_ease(aml_audio_dec_t *audec, float vol, unsigned int duration, int method)
+{
+    //adec_print("set audio volume ease1, cur=%f, vol=%f, duration=%d, method=%d\n", audec->volume_ease_cur, vol, duration, method);
+
+    audec->volume_ease_end_staging = vol;
+    audec->volume_ease_duration_staging = duration;
+    audec->volume_ease_method_staging = method;
+    audec->volume_ease_update = 1;
+}
+
 static void adec_flag_check(aml_audio_dec_t *audec)
 {
     audio_out_operations_t *aout_ops = &audec->aout_ops;
@@ -808,7 +973,7 @@ static void start_decode_thread(aml_audio_dec_t *audec)
 {
     if(audec->state != INITTED){
         adec_print("decode not inited quit \n");
-        return -1;
+        return;
     }
 
     pthread_t    tid;
@@ -819,7 +984,7 @@ static void start_decode_thread(aml_audio_dec_t *audec)
     ret = pthread_create(&tid, NULL, (void *)audio_decode_loop, (void *)audec);
     if (ret != 0) {
         adec_print("[%s]Create ffmpeg decode thread failed!\n",__FUNCTION__);
-        return ret;
+        return;
     }
     audec->sn_threadid=tid;
 	//pthread_setname_np(tid,"AmadecDecodeLP");
@@ -986,6 +1151,8 @@ QUIT:
 static char pcm_buf_tmp[AVCODEC_MAX_AUDIO_FRAME_SIZE];//max frame size out buf
 void *audio_decode_loop(void *args)
 {
+    adec_print("[%s::%d]--adec_armdec_loop start!\n",__FUNCTION__, __LINE__);
+
     int ret;
     aml_audio_dec_t *audec;
     audio_out_operations_t *aout_ops;
@@ -1012,16 +1179,21 @@ void *audio_decode_loop(void *args)
     int outlen = 0;
     struct package *p_Package;
     buffer_stream_t *g_bst;
-    AudioInfo g_AudioInfo;
+    buffer_stream_t *g_bst_raw;//for ac3&eac3 passthrough
+    AudioInfo g_AudioInfo = {0};
     adec_print("[%s]adec_armdec_loop start!\n",__FUNCTION__);
+    int dgraw = amsysfs_get_sysfs_int("/sys/class/audiodsp/digital_raw");
+
     audec = (aml_audio_dec_t *)args;
     aout_ops = &audec->aout_ops;
     adec_ops=audec->adec_ops;
     memset(outbuf, 0, AVCODEC_MAX_AUDIO_FRAME_SIZE);
     g_bst=audec->g_bst;
+    g_bst_raw=audec->g_bst_raw;
 
     nAudioFormat=audec->format;
     g_bst->format = audec->format;
+    g_bst_raw->format = audec->format;
     inlen=0;
     nNextFrameSize=adec_ops->nInBufSize;    
     while (1){
@@ -1049,9 +1221,15 @@ exit_decode_loop:
                     }
                     adec_print("[%s]Info Changed: src:sample:%d  channel:%d dest sample:%d  channel:%d \n",
                                   __FUNCTION__,g_bst->samplerate,g_bst->channels,g_AudioInfo.samplerate,g_AudioInfo.channels);
+
                     g_bst->channels=audec->channels=g_AudioInfo.channels;
                     g_bst->samplerate=audec->samplerate=g_AudioInfo.samplerate;
-                    aout_ops->pause(audec);
+                    if(g_bst_raw != NULL){
+                        g_bst_raw->channels=audec->channels=g_AudioInfo.channels;
+                        g_bst_raw->samplerate=audec->samplerate=g_AudioInfo.samplerate;
+                    }
+
+                    //aout_ops->pause(audec);//otherwise will block indefinitely at the writei_func in func pcm_write
                     audec->format_changed_flag = 1;
                }
           }
@@ -1131,20 +1309,71 @@ exit_decode_loop:
                            audec->decode_offset+=dlen;
                       }
 
-                      audec->pcm_cache_size=outlen;
-                      if(g_bst)
-                      {
-                           int wlen=0;
-                           while(outlen && !audec->exit_decode_thread) {
-                                if(g_bst->buf_length-g_bst->buf_level<outlen){
-                                   usleep(100000);
-                                   continue;
+
+                        if((ACODEC_FMT_AC3 == nAudioFormat) || (ACODEC_FMT_EAC3 == nAudioFormat)) {
+
+                            //sub the pcm header(4bytes) and the pcm data(0x1800bytes)
+                            char *output_pcm_buf = outbuf + HEADER_LENGTH_AFTER_IEC61937;
+                            int output_pcm_len = *(int *)outbuf;
+                            audec->pcm_cache_size=output_pcm_len;
+                            outlen = outlen - HEADER_LENGTH_AFTER_IEC61937 - output_pcm_len;
+
+                            //sub the raw header(4bytes) and the raw data(AC3:0x1800bytes/EAC3:0x6000bytes)
+                            char *output_raw_buf = output_pcm_buf + output_pcm_len + HEADER_LENGTH_AFTER_IEC61937;
+                            int output_raw_len = *(int *)(outbuf + HEADER_LENGTH_AFTER_IEC61937 + output_pcm_len);
+                            outlen = outlen - HEADER_LENGTH_AFTER_IEC61937 - output_raw_len;
+
+
+                            //use alsa-out.c output pcm data
+                            if(g_bst){
+                                int wlen=0;
+
+                                while(output_pcm_len && (!audec->exit_decode_thread)) {
+                                if(g_bst->buf_length-g_bst->buf_level<output_pcm_len){
+                                usleep(100000);
+                                continue;
+                                }
+
+                                wlen=write_pcm_buffer(output_pcm_buf, g_bst, output_pcm_len);
+                                output_pcm_len -= wlen;
+                                audec->pcm_cache_size-=wlen;
+                                }
+                            }
+
+                            //use alsa-out-raw.c output raw data
+                            if( (g_bst_raw) && ((AUDIO_SPDIF_PASSTHROUGH == dgraw)||(AUDIO_HDMI_PASSTHROUGH == dgraw)) )
+                            {
+                                int wlen=0;
+
+                                while(output_raw_len && !audec->exit_decode_thread) {
+                                    if(g_bst_raw->buf_length-g_bst_raw->buf_level<output_raw_len){
+                                        usleep(100000);
+                                        continue;
+                                    }
+
+                                    wlen=write_pcm_buffer(output_raw_buf, g_bst_raw,output_raw_len);
+                                    output_raw_len -= wlen;
                                 }
+
+                            }
+
+                        } else {
+                            audec->pcm_cache_size=outlen;
+                            if(g_bst) {
+                                int wlen=0;
+
+                                while(outlen && !audec->exit_decode_thread) {
+                                    if(g_bst->buf_length-g_bst->buf_level<outlen){
+                                    usleep(100000);
+                                    continue;
+                                }
+
                                 wlen=write_pcm_buffer(outbuf, g_bst,outlen); 
                                 outlen-=wlen;
                                 audec->pcm_cache_size-=wlen;
-                           }
-                      }
+                                }
+                            }
+                        }
                   }
             }else{
                   usleep(1000);
@@ -1212,6 +1441,37 @@ void *adec_armdec_loop(void *args)
         
         adec_reset_track(audec);
         adec_flag_check(audec);
+
+        if (audec->state == GAPPING) {
+            unsigned long systime;
+            adec_print("GAPPING -> resume_adec");
+            audec->state = ACTIVE;
+
+            avsync_en(0);
+            while ((!audec->need_stop) && track_switch_pts(audec)) {
+                usleep(1000);
+            }
+
+            // update APTS, not related to AV sync, just for netflix using APTS to control buffering latency
+            // do this when av sync is still disabled so it sets APTS value only
+            systime = audec->adsp_ops.get_cur_pcrscr(&audec->adsp_ops);
+            if (systime != -1) {
+                char buf[64];
+                sprintf(buf, "0x%lx", systime);
+                amsysfs_set_sysfs_str(TSYNC_APTS, buf);
+                adec_print("GAPPING -> apts: 0x%lx", systime);
+            }
+
+            // enable sync and set to AMASTER mode
+            avsync_en(1);
+            amsysfs_set_sysfs_int(TSYNC_MODE, 1);
+
+            // resume audio
+            aout_ops->resume(audec);
+            adec_pts_resume();
+            audec->auto_mute = 0;
+        }
+
         msg = adec_get_message(audec);
         if (!msg) {
             usleep(100000);
@@ -1262,13 +1522,22 @@ void *adec_armdec_loop(void *args)
                 adec_set_volume(audec, msg->value.volume);
             }
             break;
-       case CMD_SET_LRVOL:
+
+        case CMD_SET_LRVOL:
 
             adec_print("Receive Set LRVol Command!");
             if (msg->has_arg) {
                 adec_set_lrvolume(audec, msg->value.volume,msg->value_ext.volume);
             }
             break;      
+
+        case CMD_SET_VOL_EASE:
+
+            adec_print("Receive Set Vol Ease Command!");
+            if (msg->has_arg) {
+                adec_set_volume_ease(audec, msg->value.volume, msg->value_ext2, msg->value_ext.en);
+            }
+            break;      
         
         case CMD_CHANL_SWAP:
 
diff --git a/amadec/adec-internal-mgt.c b/amadec/adec-internal-mgt.c
index 74388df..836c1ca 100755
--- a/amadec/adec-internal-mgt.c
+++ b/amadec/adec-internal-mgt.c
@@ -131,7 +131,7 @@ static void start_adec(aml_audio_dec_t *audec)
 				amsysfs_get_sysfs_str(TSYNC_VPTS, buf, sizeof(buf));
 				if (sscanf(buf, "0x%lx", &vpts) < 1) {
 					adec_print("unable to get vpts from: %s", buf);
-					return -1;
+					return;
 				}
 
 				// save vpts to apts
@@ -572,6 +572,10 @@ static int set_linux_audio_decoder(aml_audio_dec_t *audec)
     }	
     value = getenv("media_arm_audio_decoder");
     adec_print("media.armdecode.audiocodec = %s, t->type = %s\n", value, t->type);
+
+    audio_decoder = AUDIO_ARM_DECODER;
+    return 0;
+
     if (value!=NULL && match_types(t->type,value))
     {	
         char type_value[] = "ac3,eac3";
@@ -581,8 +585,13 @@ static int set_linux_audio_decoder(aml_audio_dec_t *audec)
             adec_print("DOLBY_USE_ARMDEC=%d",DOLBY_USE_ARMDEC);
             audio_decoder = AUDIO_ARM_DECODER;					  
         #else
+            #if 0
             audio_decoder = AUDIO_ARC_DECODER;
             adec_print("<DOLBY_USE_ARMDEC> is not DEFINED,use ARC_Decoder\n!");
+            #else
+            audio_decoder = AUDIO_ARM_DECODER;
+            adec_print("<DOLBY_USE_ARMDEC> is DEFINED,use ARM_DECODER\n!");
+            #endif
         #endif
         }else{
             audio_decoder = AUDIO_ARM_DECODER;
@@ -634,7 +643,7 @@ int audiodec_init(aml_audio_dec_t *audec)
     int res = 0;	
     pthread_t    tid;
 	char value[PROPERTY_VALUE_MAX]={0};
-    adec_print("audiodec_init!");
+    adec_print("audiodec_init!\n");
     adec_message_pool_init(audec);
     get_output_func(audec);
     int nCodecType=audec->format;
diff --git a/amadec/adec-message.h b/amadec/adec-message.h
index 974ac2a..b91c88c 100755
--- a/amadec/adec-message.h
+++ b/amadec/adec-message.h
@@ -15,7 +15,7 @@
 
 ADEC_BEGIN_DECLS
 
-#define MESSAGE_NUM_MAX    12
+#define MESSAGE_NUM_MAX    13
 
 typedef enum {
     CMD_START = 1 << 0,
@@ -29,14 +29,15 @@ typedef enum {
     CMD_LEFT_MONO = 1 << 8,
     CMD_RIGHT_MONO = 1 << 9,
     CMD_STEREO = 1 << 10,
-    CMD_SET_LRVOL = 1<<20,    
+    CMD_SET_LRVOL = 1<<20,
+    CMD_SET_VOL_EASE = 1<<21,
     CMD_RELEASE = 1 << 31,
 } ctrl_cmd_t;
 
 
 typedef struct {
     int type;               /* 1 = reply; 0 = no reply */
-    int has_arg;         /* 1 = value is valid; 0 = value is unvalid */
+    int has_arg;         /* 1 = value is valid; 0 = value is invalid */
     ctrl_cmd_t  ctrl_cmd;
     union {
         int en;
@@ -45,7 +46,8 @@ typedef struct {
     union {
         int en;
         float volume;
-    } value_ext;	
+    } value_ext;
+    unsigned int value_ext2;
 } adec_cmd_t;
 
 typedef struct {
diff --git a/amadec/adec-pts-mgt.c b/amadec/adec-pts-mgt.c
index 750f060..1a143dc 100755
--- a/amadec/adec-pts-mgt.c
+++ b/amadec/adec-pts-mgt.c
@@ -134,9 +134,9 @@ int adec_pts_start(aml_audio_dec_t *audec)
 	    }
 	}
 
-    adec_print("audio pts start from 0x%lx", pts);
+    adec_print("audio pts start from 0x%lx\n", pts);
 
-    sprintf(buf, "AUDIO_START:0x%lx", pts);
+    sprintf(buf, "AUDIO_START:0x%lx\n", pts);
 
     if(amsysfs_set_sysfs_str(TSYNC_EVENT, buf) == -1)
     {
@@ -249,7 +249,7 @@ int adec_pts_droppcm(aml_audio_dec_t *audec)
  */
 int adec_pts_pause(void)
 {
-    adec_print("adec_pts_pause");
+    adec_print("adec_pts_pause\n");
     return amsysfs_set_sysfs_str(TSYNC_EVENT, "AUDIO_PAUSE");
 }
 
@@ -259,7 +259,7 @@ int adec_pts_pause(void)
  */
 int adec_pts_resume(void)
 {
-    adec_print("adec_pts_resume");
+    adec_print("adec_pts_resume\n");
     return amsysfs_set_sysfs_str(TSYNC_EVENT, "AUDIO_RESUME");
 
 }
@@ -325,14 +325,29 @@ int adec_refresh_pts(aml_audio_dec_t *audec)
         return 0;
     }
 
+    //adec_print("last_kernel_pts = %d", last_kernel_pts/90);
+    if ((((int)(audec->adsp_ops.kernel_audio_pts - last_kernel_pts)) > 500 * 90) && (audec->adsp_ops.last_pts_valid)) {
+        // if there is APTS interrupt (audio gap possible in Netflix NTS case)
+        adec_print("Audio gap, %d->%d", last_kernel_pts/90, audec->adsp_ops.kernel_audio_pts/90);
+        avsync_en(0);
+        adec_pts_pause();
+        audec->state = GAPPING;
+        return 0;
+    }
+
+    if (audec->state == GAPPING)
+        return 0;
+
     audec->adsp_ops.last_audio_pts = pts;
     audec->adsp_ops.last_pts_valid = 1;
 
     if (abs(pts - systime) < audec->avsync_threshold) {
-        apts_interrupt=0;
+        //adec_print("pts=0x%x, systime=0x%x, diff = %d ms", pts, systime,  ((int)(pts-systime))/90);
+        apts_interrupt=5;
         return 0;
     }
     else if(apts_interrupt>0){
+        //adec_print("apts_interrupt=%d, pts=0x%x, systime=0x%x, diff = %d ms", apts_interrupt, pts, systime, (pts-systime)/90);
         apts_interrupt --;
         return 0;
         }
@@ -386,16 +401,43 @@ int track_switch_pts(aml_audio_dec_t *audec)
 
     pcr = audec->adsp_ops.get_cur_pcrscr(&audec->adsp_ops);
     if (pcr == -1) {
-        adec_print("unable to get pcr");
+        adec_print("track_switch_pts unable to get pcr");
         return 1;
     }
 
     apts = adec_calc_pts(audec);
     if (apts == -1) {
-        adec_print("unable to get apts");
+        adec_print("track_switch_pts unable to get apts");
         return 1;
     }
     
+    // adec_calc_pts returns apts with fixed track latency correct,
+    // which is not correctly reflects the delay when output has not
+    // been started at switching case.
+    // accurate timeing control for when to start feeding audio data
+    // is important to make audio switching smooth and avoid resetting
+    // system time from APTS of the new audio track. We need start audio
+    // track feeding to make the time stamp of the first audio sample
+    // output from HW is exactly the system time set up before switching.
+    // Unfurtunately, we never know how long it will take at Android
+    // AudioFlinger. adec_calc_pts has a fixed latency applied to APTS,
+    // when audio buffers in the AudioFlinger/Output pipeline is full,
+    // this offset is almost right. However, when initially the pipeline
+    // is all empty, use fixed latency is not correct.
+    // The number given below is a correction on top of the fixed latency.
+    // e.g., assuming system time is 10000ms, first apts is 12000ms, latency
+    // is 100ms, then adec_calc_pts returns 12000-100 = 11900ms. The external
+    // loop will wait 100ms to finish switching wait. When system time is 11900ms,
+    // audio data with 12000ms is fed to AudioFlinger, but it does not take 100ms
+    // to get output. With 100ms fixed latency, the data feeding is too earlier
+    // and this will cause apts reset system time soon.
+    // the number below of 50ms is from experiment. It assumes the time between
+    // first data feeding to output is 100-50=50ms. 
+
+    apts += 50*90;
+
+    adec_print("track_switch_pts apts=%d, pcr=%d, kernel_pts=%d\n", apts/90, pcr/90, audec->adsp_ops.kernel_audio_pts/90);
+
     if((apts > pcr) && (apts - pcr > 0x100000))
         return 0;
 		
diff --git a/amadec/adec-pts-mgt.h b/amadec/adec-pts-mgt.h
index f401a1e..29bcbe4 100755
--- a/amadec/adec-pts-mgt.h
+++ b/amadec/adec-pts-mgt.h
@@ -21,6 +21,7 @@ ADEC_BEGIN_DECLS
 #define TSYNC_VPTS      "/sys/class/tsync/pts_video"
 #define TSYNC_ENABLE  "/sys/class/tsync/enable"
 #define TSYNC_LAST_CHECKIN_APTS "/sys/class/tsync/last_checkin_apts"
+#define TSYNC_MODE   "/sys/class/tsync/mode"
 
 #define SYSTIME_CORRECTION_THRESHOLD        (90000*15/100)
 #define APTS_DISCONTINUE_THRESHOLD          (90000*3)
diff --git a/amadec/adec_read.c b/amadec/adec_read.c
index 36773d2..49fd0ce 100755
--- a/amadec/adec_read.c
+++ b/amadec/adec_read.c
@@ -39,6 +39,9 @@ volatile unsigned* reg_base = 0;
 #define WRITE_MPEG_REG(reg, val) reg_base[reg-AIU_AIFIFO_CTRL]=val
 #define AIFIFO_READY  (((READ_MPEG_REG(AIU_MEM_AIFIFO_CONTROL)&(1<<9))))
 #define min(x,y) ((x<y)?(x):(y))
+
+static volatile long memmap = MAP_FAILED;
+static int phys_size = 0;
 
 static unsigned long  get_num_infile(char *file)
 {
@@ -49,9 +52,9 @@ int uio_init(aml_audio_dec_t *audec){
 //	int fd = -1; 
 	int pagesize = getpagesize();
 	int phys_start;
-	int phys_size;
+//	int phys_size;
 	int phys_offset;
-	volatile unsigned memmap;	
+//	volatile unsigned memmap;	
 
 
 	audec->fd_uio = open(ASTREAM_DEV, O_RDWR);
@@ -74,6 +77,9 @@ int uio_init(aml_audio_dec_t *audec){
 		return -1;
 	}	 
 	 
+	if (phys_offset == 0)
+		phys_offset = (AIU_AIFIFO_CTRL*4)&(pagesize-1);
+
 	reg_base = memmap + phys_offset;
 	return 0;
 }
diff --git a/amadec/adec_write.h b/amadec/adec_write.h
index e9d0cfa..0d14971 100755
--- a/amadec/adec_write.h
+++ b/amadec/adec_write.h
@@ -6,7 +6,9 @@
 #include <string.h>
 
 #define DEFAULT_BUFFER_SIZE 1024*1024
+#ifndef MIN
 #define MIN(a,b) (a>b)?b:a
+#endif
 
 typedef struct buffer_stream_st{
     int buf_length;
diff --git a/amadec/audio-dec.h b/amadec/audio-dec.h
index 4a21edd..7f44096 100755
--- a/amadec/audio-dec.h
+++ b/amadec/audio-dec.h
@@ -35,16 +35,15 @@ ADEC_BEGIN_DECLS
 
 //for ffmpeg audio decode
 #define AMSTREAM_IOC_MAGIC  'S'
-#define AMSTREAM_IOC_APTS_LOOKUP    _IOR(AMSTREAM_IOC_MAGIC, 0x81,unsigned long)   
-#define GET_FIRST_APTS_FLAG			_IOR(AMSTREAM_IOC_MAGIC, 0x82, long)
-
+#define AMSTREAM_IOC_APTS_LOOKUP    _IOR((AMSTREAM_IOC_MAGIC), 0x81, int)  
+#define GET_FIRST_APTS_FLAG    _IOR((AMSTREAM_IOC_MAGIC), 0x82, int)
 //-----------------------------------------------
 //copy from file: "../amcodec/include/amports/amstream.h"
 #ifndef AMSTREAM_IOC_PCRSCR
-#define AMSTREAM_IOC_PCRSCR           _IOR(AMSTREAM_IOC_MAGIC, 0x42, unsigned long)
+#define AMSTREAM_IOC_PCRSCR  _IOR((AMSTREAM_IOC_MAGIC), 0x42, int)
 #endif
 #ifndef AMSTREAM_IOC_SET_APTS
-#define AMSTREAM_IOC_SET_APTS         _IOW(AMSTREAM_IOC_MAGIC, 0xa8, unsigned long)
+#define AMSTREAM_IOC_SET_APTS  _IOW((AMSTREAM_IOC_MAGIC), 0xa8, int)
 #endif
 
 //-----------------------------------------------
@@ -136,8 +135,8 @@ struct aml_audio_dec {
 
     buffer_stream_t *g_bst;
     buffer_stream_t *g_bst_raw;
-    int sn_threadid;
-    int sn_getpackage_threadid;
+    pthread_t sn_threadid;
+    pthread_t sn_getpackage_threadid;
     int exit_decode_thread;
     int exit_decode_thread_success;
     unsigned long decode_offset;
@@ -159,6 +158,18 @@ struct aml_audio_dec {
     fp_arm_omx_codec_get_FS     parm_omx_codec_get_FS;
     fp_arm_omx_codec_get_Nch    parm_omx_codec_get_Nch;
     int OmxFirstFrameDecoded;
+    float volume_ease_start;
+    float volume_ease_cur;
+    float volume_ease_end;
+    unsigned int volume_ease_duration;
+    unsigned int volume_ease_sample;
+    int volume_ease_method;
+    int volume_ease_update;
+    float volume_ease_end_staging;
+    unsigned int volume_ease_duration_staging;
+    int volume_ease_method_staging;
+
+    int gap_end_pts;
 };
 
 //from amcodec
@@ -175,6 +186,7 @@ typedef struct {
 	int SessionID;
 	int dspdec_not_supported;//check some profile that audiodsp decoder can not support,we switch to arm decoder	
 	int droppcm_flag;				// drop pcm flag, if switch audio (1)
+	int automute;
 } arm_audio_info;
 
  typedef struct {
@@ -229,6 +241,13 @@ struct adec_status {
 #define    ACODEC_FMT_WIFIDISPLAY 22
 
 
+//audio output type
+
+#define    AUDIO_PCM_OUTPUT 0//output pcm data
+#define    AUDIO_SPDIF_PASSTHROUGH 1//passthrough type as dd
+#define    AUDIO_HDMI_PASSTHROUGH 2//passthrough type as ddplus
+
+
 /***********************************************************************************************/
 extern void android_basic_init(void);
 int audiodec_init(aml_audio_dec_t *aml_audio_dec);
diff --git a/amadec/audio_out/alsa-out-raw.c b/amadec/audio_out/alsa-out-raw.c
new file mode 100644
index 0000000..a7d92e2
--- /dev/null
+++ b/amadec/audio_out/alsa-out-raw.c
@@ -0,0 +1,842 @@
+/**
+ * \file alsa-out.c
+ * \brief  Functions of Auduo output control for Linux Platform
+ * \version 1.0.0
+ * \date 2011-03-08
+ */
+/* Copyright (C) 2007-2011, Amlogic Inc.
+ * All right reserved
+ *
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <sys/soundcard.h>
+//#include <config.h>
+#include <alsa/asoundlib.h>
+#include <alsa/pcm.h>
+#include <audio-dec.h>
+#include <adec-pts-mgt.h>
+#include <log-print.h>
+#include <alsa-out.h>
+#include "alsactl_parser.h"
+#include "alsa-out-raw.h"
+
+//#define adec_print printf
+#define adec_print
+
+#define   PERIOD_SIZE  1024
+#define   PERIOD_NUM    4
+
+static snd_pcm_sframes_t (*readi_func)(snd_pcm_t *handle, void *buffer, snd_pcm_uframes_t size);
+static snd_pcm_sframes_t (*writei_func)(snd_pcm_t *handle, const void *buffer, snd_pcm_uframes_t size);
+static snd_pcm_sframes_t (*readn_func)(snd_pcm_t *handle, void **bufs, snd_pcm_uframes_t size);
+static snd_pcm_sframes_t (*writen_func)(snd_pcm_t *handle, void **bufs, snd_pcm_uframes_t size);
+
+
+static int fragcount = PERIOD_NUM;
+static snd_pcm_uframes_t chunk_size = PERIOD_SIZE;
+static char output_buffer[64 * 1024];
+static unsigned char decode_buffer[OUTPUT_BUFFER_SIZE + 64];
+
+
+static int set_params_raw(alsa_param_t *alsa_params);
+
+
+int alsa_get_aml_card()
+{
+    int card = -1, err = 0;
+    int fd = -1;
+    unsigned fileSize = 512;
+    char *read_buf = NULL, *pd = NULL;
+    static const char *const SOUND_CARDS_PATH = "/proc/asound/cards";
+    fd = open(SOUND_CARDS_PATH, O_RDONLY);
+    if (fd < 0) {
+        adec_print("ERROR: failed to open config file %s error: %d\n", SOUND_CARDS_PATH, errno);
+        close(fd);
+        return -1;
+    }
+
+    read_buf = (char *)malloc(fileSize);
+    if (!read_buf) {
+        adec_print("Failed to malloc read_buf");
+        close(fd);
+        return -1;
+    }
+    memset(read_buf, 0x0, fileSize);
+    err = read(fd, read_buf, fileSize);
+    if (fd < 0) {
+        adec_print("ERROR: failed to read config file %s error: %d\n", SOUND_CARDS_PATH, errno);
+        free(read_buf);
+        close(fd);
+        return -1;
+    }
+    pd = strstr(read_buf, "AML");
+    card = *(pd - 3) - '0';
+
+OUT:
+    free(read_buf);
+    close(fd);
+    return card;
+}
+
+int alsa_get_spdif_port()
+{
+    int port = -1, err = 0;
+    int fd = -1;
+    unsigned fileSize = 512;
+    char *read_buf = NULL, *pd = NULL;
+    static const char *const SOUND_PCM_PATH = "/proc/asound/pcm";
+    fd = open(SOUND_PCM_PATH, O_RDONLY);
+    if (fd < 0) {
+        adec_print("ERROR: failed to open config file %s error: %d\n", SOUND_PCM_PATH, errno);
+        close(fd);
+        return -1;
+    }
+
+    read_buf = (char *)malloc(fileSize);
+    if (!read_buf) {
+        adec_print("Failed to malloc read_buf");
+        close(fd);
+        return -1;
+    }
+    memset(read_buf, 0x0, fileSize);
+    err = read(fd, read_buf, fileSize);
+    if (fd < 0) {
+        adec_print("ERROR: failed to read config file %s error: %d\n", SOUND_PCM_PATH, errno);
+        free(read_buf);
+        close(fd);
+        return -1;
+    }
+    pd = strstr(read_buf, "SPDIF");
+    if (!pd) {
+        goto OUT;
+    }
+    adec_print("%s  \n", pd);
+
+    port = *(pd - 3) - '0';
+    adec_print("%s  \n", (pd - 3));
+
+OUT:
+    free(read_buf);
+    close(fd);
+    return port;
+}
+
+int alsa_swtich_port(alsa_param_t *alsa_params, int card, int port)
+{
+    char dev[10] = {0};
+    adec_print("card = %d, port = %d\n", card, port);
+    sprintf(dev, "hw:%d,%d", (card >= 0) ? card : 0, (port >= 0) ? port : 0);
+    pthread_mutex_lock(&alsa_params->playback_mutex);
+    snd_pcm_drop(alsa_params->handle);
+    snd_pcm_close(alsa_params->handle);
+    alsa_params->handle = NULL;
+    int err = snd_pcm_open(&alsa_params->handle, dev, SND_PCM_STREAM_PLAYBACK, 0);
+
+    if (err < 0) {
+        adec_print("audio open error: %s", snd_strerror(err));
+        pthread_mutex_unlock(&alsa_params->playback_mutex);
+        return -1;
+    }
+
+    set_params_raw(alsa_params);
+    pthread_mutex_unlock(&alsa_params->playback_mutex);
+
+    return 0;
+}
+
+
+static int set_params_raw(alsa_param_t *alsa_params)
+{
+    snd_pcm_hw_params_t *hwparams;
+    snd_pcm_sw_params_t *swparams;
+    //  snd_pcm_uframes_t buffer_size;
+    //  snd_pcm_uframes_t boundary;
+    //  unsigned int period_time = 0;
+    //  unsigned int buffer_time = 0;
+    snd_pcm_uframes_t bufsize;
+    int err;
+    unsigned int rate;
+    snd_pcm_uframes_t start_threshold, stop_threshold;
+    snd_pcm_hw_params_alloca(&hwparams);
+    snd_pcm_sw_params_alloca(&swparams);
+
+    err = snd_pcm_hw_params_any(alsa_params->handle, hwparams);
+    if (err < 0) {
+        adec_print("Broken configuration for this PCM: no configurations available");
+        return err;
+    }
+
+    err = snd_pcm_hw_params_set_access(alsa_params->handle, hwparams,
+                                       SND_PCM_ACCESS_RW_INTERLEAVED);
+    if (err < 0) {
+        adec_print("Access type not available");
+        return err;
+    }
+
+    err = snd_pcm_hw_params_set_format(alsa_params->handle, hwparams, alsa_params->format);
+    if (err < 0) {
+        adec_print("Sample format non available");
+        return err;
+    }
+
+    err = snd_pcm_hw_params_set_channels(alsa_params->handle, hwparams, alsa_params->channelcount);
+    if (err < 0) {
+        adec_print("Channels count non available");
+        return err;
+    }
+
+    rate = alsa_params->rate;
+    err = snd_pcm_hw_params_set_rate_near(alsa_params->handle, hwparams, &alsa_params->rate, 0);
+    assert(err >= 0);
+#if 0
+    err = snd_pcm_hw_params_get_buffer_time_max(hwparams,  &buffer_time, 0);
+    assert(err >= 0);
+    if (buffer_time > 500000) {
+        buffer_time = 500000;
+    }
+
+    period_time = buffer_time / 4;
+
+    err = snd_pcm_hw_params_set_period_time_near(handle, hwparams,
+            &period_time, 0);
+    assert(err >= 0);
+
+    err = snd_pcm_hw_params_set_buffer_time_near(handle, hwparams,
+            &buffer_time, 0);
+    assert(err >= 0);
+
+#endif
+    alsa_params->bits_per_sample = snd_pcm_format_physical_width(alsa_params->format);
+    //bits_per_frame = bits_per_sample * hwparams.realchanl;
+    alsa_params->bits_per_frame = alsa_params->bits_per_sample * alsa_params->channelcount;
+
+    bufsize = 	PERIOD_NUM*PERIOD_SIZE*4;
+
+    err = snd_pcm_hw_params_set_buffer_size_near(alsa_params->handle, hwparams,&bufsize);
+    if (err < 0) {
+        adec_print("Unable to set  buffer  size \n");
+        return err;
+    }
+	
+    err = snd_pcm_hw_params_set_period_size_near(alsa_params->handle, hwparams, &chunk_size, NULL);
+    if (err < 0) {
+        adec_print("Unable to set period size \n");
+        return err;
+    }
+#if 0	
+    err = snd_pcm_hw_params_set_periods_near(alsa_params->handle, hwparams, &fragcount, NULL);
+    if (err < 0) {
+      adec_print("Unable to set periods \n");
+      return err;
+    }
+#endif	
+    err = snd_pcm_hw_params(alsa_params->handle, hwparams);
+    if (err < 0) {
+        adec_print("Unable to install hw params:");
+        return err;
+    }
+
+    err = snd_pcm_hw_params_get_buffer_size(hwparams, &bufsize);
+    if (err < 0) {
+        adec_print("Unable to get buffersize \n");
+        return err;
+    }
+    adec_print("[%s::%d]--[alsa raw buffer frame size:%d]\n", __FUNCTION__, __LINE__,bufsize);
+    alsa_params->buffer_size = bufsize * alsa_params->bits_per_frame / 8;
+
+#if 1
+    err = snd_pcm_sw_params_current(alsa_params->handle, swparams);
+    if (err < 0) {
+        adec_print("??Unable to get sw-parameters\n");
+        return err;
+    }
+
+    //err = snd_pcm_sw_params_get_boundary(swparams, &boundary);
+    //if (err < 0){
+    //  adec_print("Unable to get boundary\n");
+    //  return err;
+    //}
+
+    //err = snd_pcm_sw_params_set_start_threshold(handle, swparams, bufsize);
+    //if (err < 0) {
+    //  adec_print("Unable to set start threshold \n");
+    //  return err;
+    //}
+
+    //err = snd_pcm_sw_params_set_stop_threshold(handle, swparams, buffer_size);
+    //if (err < 0) {
+    //  adec_print("Unable to set stop threshold \n");
+    //  return err;
+    //}
+
+    //  err = snd_pcm_sw_params_set_silence_size(handle, swparams, buffer_size);
+    //  if (err < 0) {
+    //      adec_print("Unable to set silence size \n");
+    //      return err;
+    //  }
+
+    err = snd_pcm_sw_params(alsa_params->handle, swparams);
+    if (err < 0) {
+        adec_print("Unable to get sw-parameters\n");
+        return err;
+    }
+
+    //snd_pcm_sw_params_free(swparams);
+#endif
+
+
+    //chunk_bytes = chunk_size * bits_per_frame / 8;
+
+    return 0;
+}
+
+static size_t pcm_write_raw(alsa_param_t * alsa_param, u_char * data, size_t count)
+{
+
+    snd_pcm_sframes_t r;
+    size_t result = 0;
+
+    /*
+        if (count < chunk_size) {
+            snd_pcm_format_set_silence(hwparams.format, data + count * bits_per_frame / 8, (chunk_size - count) * hwparams.channels);
+            count = chunk_size;
+        }
+    */
+    while (count > 0) {		
+        r = writei_func(alsa_param->handle, data, count);
+
+        if (r == -EINTR) {
+            r = 0;
+        }
+        if (r == -ESTRPIPE) {
+            while ((r = snd_pcm_resume(alsa_param->handle)) == -EAGAIN) {
+                sleep(1);
+            }
+        }
+
+        if (r < 0) {
+            //printf("xun in\n");
+            if ((r = snd_pcm_prepare(alsa_param->handle)) < 0) {
+                return 0;
+            }
+        }
+
+        if (r > 0) {
+            result += r;
+            count -= r;
+            data += r * alsa_param->bits_per_frame / 8;
+        }
+    }
+    return result;
+}
+
+
+//spdif output data align
+static int alsa_play_raw(alsa_param_t * alsa_param, char * data, unsigned len)
+{
+    size_t l = 0, r;
+    if (!alsa_param->flag) {
+        l = len * 8 / alsa_param->bits_per_frame;
+        l = l & (~(32 - 1)); /*driver only support  32 frames each time */
+        r = pcm_write_raw(alsa_param, data, l);
+        r = r * alsa_param->bits_per_frame / 8;
+    }
+
+    return r ;
+}
+
+static void *alsa_playback_raw_loop(void *args)
+{
+
+    int len = 0;
+    int len2 = 0;
+    int offset = 0;
+    aml_audio_dec_t *audec;
+    alsa_param_t *alsa_params;
+    alsa_param_t *alsa_params_pcm;
+    unsigned char *buffer = (unsigned char *)(((unsigned long)decode_buffer + 32) & (~0x1f));
+
+    audec = (aml_audio_dec_t *)args;
+    alsa_params = (alsa_param_t *)audec->aout_ops.private_data_raw;
+ /*   pthread_mutex_init(&alsa_params->playback_mutex, NULL);
+    pthread_cond_init(&alsa_params->playback_cond, NULL);*/
+
+    pthread_mutex_lock(&alsa_params->playback_mutex);
+    
+    while( !alsa_params->wait_flag )	
+    {
+        adec_print("yvonnepthread_cond_wait\n");
+         pthread_cond_wait(&alsa_params->playback_cond, &alsa_params->playback_mutex);
+    }
+    alsa_params->wait_flag=1;
+    pthread_mutex_unlock(&alsa_params->playback_mutex);
+
+
+    while (!alsa_params->stop_flag) {
+        while ((len < (128 * 2)) && (!alsa_params->stop_flag)) {
+            if (offset > 0) {
+                memcpy(buffer, buffer + offset, len);
+            }
+            len2 = audec->adsp_ops.dsp_read_raw(&audec->adsp_ops, (buffer + len), (OUTPUT_BUFFER_SIZE - len));
+            len = len + len2;
+            offset = 0;
+        }
+
+        while (alsa_params->pause_flag) {
+            usleep(10000);
+        }
+
+        len2 = alsa_play_raw(alsa_params, (buffer + offset), len);
+
+        if (len2 >= 0) {
+            len -= len2;
+            offset += len2;
+        } else {
+            len = 0;
+            offset = 0;
+        }
+
+    }
+
+    adec_print("Exit alsa playback raw loop !\n");
+    pthread_exit(NULL);
+    return NULL;
+}
+
+/**
+ * \brief output initialization
+ * \param audec pointer to audec
+ * \return 0 on success otherwise negative error code
+ */
+int alsa_init_raw(struct aml_audio_dec* audec)
+{
+
+    int err = 0;
+    pthread_t tid;
+    alsa_param_t *alsa_param;
+    audio_out_operations_t *out_ops = &audec->aout_ops;
+    int sound_card_id = 0;
+    int sound_dev_id = 0;
+    char sound_card_dev[10] = {0};
+
+    int dgraw = amsysfs_get_sysfs_int("/sys/class/audiodsp/digital_raw");
+
+    if((AUDIO_SPDIF_PASSTHROUGH == dgraw)||(AUDIO_HDMI_PASSTHROUGH == dgraw)){
+    if(audec->format == ACODEC_FMT_AC3){
+        amsysfs_set_sysfs_int("/sys/class/audiodsp/digital_codec",2);
+        audec->codec_type=1;
+    }else if(audec->format == ACODEC_FMT_EAC3){
+        amsysfs_set_sysfs_int("/sys/class/audiodsp/digital_codec",4);
+        audec->codec_type=4;
+    }
+    }
+
+    if(AUDIO_PCM_OUTPUT == dgraw) {
+        adec_print("OUT SETTING::PCM\n");
+        out_ops->private_data_raw = NULL;
+        return -1;
+    }
+
+
+    alsa_param = (alsa_param_t *)malloc(sizeof(alsa_param_t));
+    if (!alsa_param) {
+        adec_print("alloc alsa_param failed, not enough memory!");
+        return -1;
+    }
+    memset(alsa_param, 0, sizeof(alsa_param_t));
+    
+    if (audec->samplerate >= (88200 + 96000) / 2) {
+        alsa_param->flag = 1;
+        alsa_param->oversample = -1;
+        alsa_param->rate = 48000;
+    } else if (audec->samplerate >= (64000 + 88200) / 2) {
+        alsa_param->flag = 1;
+        alsa_param->oversample = -1;
+        alsa_param->rate = 44100;
+    } else if (audec->samplerate >= (48000 + 64000) / 2) {
+        alsa_param->flag = 1;
+        alsa_param->oversample = -1;
+        alsa_param->rate = 32000;
+    } else if (audec->samplerate >= (44100 + 48000) / 2) {
+        alsa_param->oversample = 0;
+        alsa_param->rate = 48000;
+        if (audec->channels == 1) {
+            alsa_param->flag = 1;
+        } else if (audec->channels == 2) {
+            alsa_param->flag = 0;
+        }
+    } else if (audec->samplerate >= (32000 + 44100) / 2) {
+        alsa_param->oversample = 0;
+        alsa_param->rate = 44100;
+        if (audec->channels == 1) {
+            alsa_param->flag = 1;
+        } else if (audec->channels == 2) {
+            alsa_param->flag = 0;
+        }
+    } else if (audec->samplerate >= (24000 + 32000) / 2) {
+        alsa_param->oversample = 0;
+        alsa_param->rate = 32000;
+        if (audec->channels == 1) {
+            alsa_param->flag = 1;
+        } else if (audec->channels == 2) {
+            alsa_param->flag = 0;
+        }
+    } else if (audec->samplerate >= (22050 + 24000) / 2) {
+        alsa_param->flag = 1;
+        alsa_param->oversample = 1;
+        alsa_param->rate = 48000;
+    } else if (audec->samplerate >= (16000 + 22050) / 2) {
+        alsa_param->flag = 1;
+        alsa_param->oversample = 1;
+        alsa_param->rate = 44100;
+    } else if (audec->samplerate >= (12000 + 16000) / 2) {
+        alsa_param->flag = 1;
+        alsa_param->oversample = 1;
+        alsa_param->rate = 32000;
+    } else if (audec->samplerate >= (11025 + 12000) / 2) {
+        alsa_param->flag = 1;
+        alsa_param->oversample = 2;
+        alsa_param->rate = 48000;
+    } else if (audec->samplerate >= (8000 + 11025) / 2) {
+        alsa_param->flag = 1;
+        alsa_param->oversample = 2;
+        alsa_param->rate = 44100;
+    } else {
+        alsa_param->flag = 1;
+        alsa_param->oversample = 2;
+        alsa_param->rate = 32000;
+    }
+
+    alsa_param->channelcount = 2;
+    alsa_param->realchanl = audec->channels;
+    //alsa_param->rate = audec->samplerate;
+    alsa_param->format = SND_PCM_FORMAT_S16_LE;
+    alsa_param->wait_flag=0;
+
+    sound_card_id = alsa_get_aml_card();
+    if (sound_card_id  < 0) {
+        sound_card_id = 0;
+        adec_print("[%s::%d]--[get aml card fail, use default]\n",__FUNCTION__, __LINE__);
+    }
+    adec_print("[%s::%d]--[alsa_get_aml_card return:%d]\n",__FUNCTION__, __LINE__,sound_card_id);
+
+    sound_dev_id = alsa_get_spdif_port();
+    if (sound_dev_id < 0) {
+        sound_dev_id = 0;
+        adec_print("[%s::%d]--[get aml card device fail, use default]\n",__FUNCTION__, __LINE__);
+    }
+
+    adec_print("[%s::%d]--[sound_dev_id(spdif) return:%d]\n",__FUNCTION__, __LINE__,sound_dev_id);
+
+    sprintf(sound_card_dev, "hw:%d,%d", sound_card_id, sound_dev_id);
+
+    adec_print("[%s::%d]--[sound_card_dev:%s]\n",__FUNCTION__, __LINE__,sound_card_dev);
+
+    err = snd_pcm_open(&alsa_param->handle, sound_card_dev, SND_PCM_STREAM_PLAYBACK, 0);
+    if (err < 0) {
+        adec_print("[%s::%d]--[audio open error: %s]\n", __FUNCTION__, __LINE__,snd_strerror(err));
+
+        snd_pcm_drop(alsa_param->handle);
+        snd_pcm_close(alsa_param->handle);
+        return -1;
+    } else {
+        adec_print("[%s::%d]--[audio open(snd_pcm_open) successfully]\n", __FUNCTION__, __LINE__);
+    }
+
+
+    readi_func = snd_pcm_readi;
+    writei_func = snd_pcm_writei;
+    readn_func = snd_pcm_readn;
+    writen_func = snd_pcm_writen;
+
+    set_params_raw(alsa_param);
+
+    out_ops->private_data_raw = (void *)alsa_param;
+
+    /*TODO:  create play thread */
+    pthread_mutex_init(&alsa_param->playback_mutex, NULL);
+    pthread_cond_init(&alsa_param->playback_cond, NULL);
+    err = pthread_create(&tid, NULL, (void *)alsa_playback_raw_loop, (void *)audec);
+    if (err != 0) {
+        adec_print("alsa_playback_raw_loop thread create failed!");
+        snd_pcm_close(alsa_param->handle);
+        return -1;
+    }
+    adec_print("Create alsa_playback_raw_loop thread success ! tid = %d\n", tid);
+
+    alsa_param->playback_tid = tid;
+
+    alsactl_parser();
+    return 0;
+}
+
+/**
+ * \brief start output
+ * \param audec pointer to audec
+ * \return 0 on success otherwise negative error code
+ *
+ * Call alsa_start(), then the callback will start being called.
+ */
+int alsa_start_raw(struct aml_audio_dec* audec)
+{
+    alsa_param_t *alsa_param;
+
+    audio_out_operations_t *out_ops = &audec->aout_ops;
+    if(out_ops->private_data_raw) {
+        alsa_param = (alsa_param_t *)out_ops->private_data_raw;
+    } else {
+        adec_print("OUT SETTING::PCM\n");
+        return -1;
+    }
+
+    pthread_mutex_lock(&alsa_param->playback_mutex);
+    adec_print("yvonne pthread_cond_signalalsa_param->wait_flag=1\n");
+    alsa_param->wait_flag=1;//yvonneadded
+    pthread_cond_signal(&alsa_param->playback_cond);
+    pthread_mutex_unlock(&alsa_param->playback_mutex);
+
+    return 0;
+}
+
+/**
+ * \brief pause output
+ * \param audec pointer to audec
+ * \return 0 on success otherwise negative error code
+ */
+int alsa_pause_raw(struct aml_audio_dec* audec)
+{
+
+    int res = 0;
+    alsa_param_t *alsa_params;
+
+    if(audec->aout_ops.private_data_raw) {
+        alsa_params = (alsa_param_t *)audec->aout_ops.private_data_raw;
+    } else {
+        adec_print("OUT SETTING::PCM\n");
+        return -1;
+    }
+    if(1 == alsa_params->pause_flag) {
+        adec_print("[%s::%d]--[already in pause(%d) status]\n",__FUNCTION__, __LINE__,alsa_params->pause_flag);
+        return 0;
+    }
+
+    alsa_params->pause_flag = 1;
+    while ((res = snd_pcm_pause(alsa_params->handle, 1)) == -EAGAIN) {
+        sleep(1);
+    }
+
+    return res;
+}
+
+/**
+ * \brief resume output
+ * \param audec pointer to audec
+ * \return 0 on success otherwise negative error code
+ */
+int alsa_resume_raw(struct aml_audio_dec* audec)
+{
+
+    int res = 0;
+    alsa_param_t *alsa_params;
+
+    if(audec->aout_ops.private_data_raw) {
+        alsa_params = (alsa_param_t *)audec->aout_ops.private_data_raw;
+    } else {
+        adec_print("OUT SETTING::PCM\n");
+        return -1;
+    }
+
+    alsa_params->pause_flag = 0;
+    while ((res = snd_pcm_pause(alsa_params->handle, 0)) == -EAGAIN) {
+        sleep(1);
+    }
+
+    return res;
+}
+
+/**
+ * \brief stop output
+ * \param audec pointer to audec
+ * \return 0 on success otherwise negative error code
+ */
+int alsa_stop_raw(struct aml_audio_dec* audec)
+{
+    alsa_param_t *alsa_params;
+    int res = 0;
+    int dgraw = amsysfs_get_sysfs_int("/sys/class/audiodsp/digital_raw");
+
+    if(audec->aout_ops.private_data_raw) {
+        alsa_params = (alsa_param_t *)audec->aout_ops.private_data_raw;
+    } else {
+        adec_print("OUT SETTING::PCM\n");
+        return -1;
+    }
+
+    //resume the spdif card, otherwise the output will block
+    if(alsa_params->pause_flag == 1){
+        while ((res = snd_pcm_pause(alsa_params->handle, 0)) == -EAGAIN) {
+            usleep(1000);
+        }
+    }
+
+    alsa_params->pause_flag = 0; //we should clear pause flag ,as we can stop from paused state
+    alsa_params->stop_flag = 1;
+    alsa_params->wait_flag = 0;
+
+    pthread_cond_signal(&alsa_params->playback_cond);
+    pthread_join(alsa_params->playback_tid, NULL);
+    pthread_mutex_destroy(&alsa_params->playback_mutex);
+    pthread_cond_destroy(&alsa_params->playback_cond);
+
+
+    snd_pcm_drop(alsa_params->handle);
+    snd_pcm_close(alsa_params->handle);
+
+    free(alsa_params);
+    audec->aout_ops.private_data_raw = NULL;
+    adec_print("exit alsa out raw stop\n");
+    if((AUDIO_SPDIF_PASSTHROUGH == dgraw)||(AUDIO_HDMI_PASSTHROUGH == dgraw)){
+        if((audec->format == ACODEC_FMT_AC3) ||(audec->format == ACODEC_FMT_EAC3) ){
+            amsysfs_set_sysfs_int("/sys/class/audiodsp/digital_codec",0);
+        }
+    }
+
+    return 0;
+}
+
+
+
+/**
+ * \brief get output latency in ms
+ * \param audec pointer to audec
+ * \return output latency
+ */
+unsigned long alsa_latency_raw(struct aml_audio_dec* audec)
+{
+    return 0;
+}
+
+/**
+* alsa dumy codec controls interface
+*/
+int dummy_alsa_control_raw(char * id_string , long vol, int rw, long * value){
+    int err;
+    snd_hctl_t *hctl;
+    snd_ctl_elem_id_t *id;
+    snd_hctl_elem_t *elem;
+    snd_ctl_elem_value_t *control;
+    snd_ctl_elem_info_t *info;
+    snd_ctl_elem_type_t type;
+    unsigned int idx = 0, count;
+    long tmp, min, max;
+    char dev[10] = {0};
+    int card = alsa_get_aml_card();
+    int port = alsa_get_spdif_port();
+
+    adec_print("card = %d, port = %d\n", card, port);
+    sprintf(dev, "hw:%d,%d", (card >= 0) ? card : 0, (port >= 0) ? port : 0);
+
+    if ((err = snd_hctl_open(&hctl, dev, 0)) < 0) { 
+        printf("Control %s open error: %s\n", dev, snd_strerror(err));
+        return err;
+    }
+    if (err = snd_hctl_load(hctl)< 0) {
+        printf("Control %s open error: %s\n", dev, snd_strerror(err));
+        return err;
+    }
+    snd_ctl_elem_id_alloca(&id);
+    snd_ctl_elem_id_set_interface(id, SND_CTL_ELEM_IFACE_MIXER);
+    snd_ctl_elem_id_set_name(id, id_string);
+    elem = snd_hctl_find_elem(hctl, id);
+    snd_ctl_elem_value_alloca(&control);
+    snd_ctl_elem_value_set_id(control, id);
+    snd_ctl_elem_info_alloca(&info);
+    if ((err = snd_hctl_elem_info(elem, info)) < 0) {
+        printf("Control %s snd_hctl_elem_info error: %s\n", dev, snd_strerror(err));
+        return err;
+    }    
+    count = snd_ctl_elem_info_get_count(info);
+    type = snd_ctl_elem_info_get_type(info);
+    
+    for (idx = 0; idx < count; idx++) {
+        switch (type) {
+            case SND_CTL_ELEM_TYPE_BOOLEAN:
+                if(rw){
+                    tmp = 0;
+                    if (vol >= 1) {
+                        tmp = 1;
+                    }
+                    snd_ctl_elem_value_set_boolean(control, idx, tmp);
+                    err = snd_hctl_elem_write(elem, control);
+                }else             	
+            *value = snd_ctl_elem_value_get_boolean(control, idx);
+            break;
+            case SND_CTL_ELEM_TYPE_INTEGER:
+                if(rw){
+            min = snd_ctl_elem_info_get_min(info);
+            max = snd_ctl_elem_info_get_max(info);
+                    if ((vol >= min) && (vol <= max))
+                        tmp = vol;
+            else if (vol < min)
+                        tmp = min;
+                    else if (vol > max)
+                        tmp = max;
+                    snd_ctl_elem_value_set_integer(control, idx, tmp);
+                    err = snd_hctl_elem_write(elem, control);
+                }else             	
+                *value = snd_ctl_elem_value_get_integer(control, idx);
+            break;
+            default:
+                printf("?");
+            break;
+        }
+        if (err < 0){
+            printf ("control%s access error=%s,close control device\n", dev, snd_strerror(err));
+            snd_hctl_close(hctl);
+            return err;
+        }
+    }
+    
+    return 0;
+}
+/**
+ * \brief mute output
+ * \param audec pointer to audec
+ * \param en  1 = mute, 0 = unmute
+ * \return 0 on success otherwise negative error code
+ */
+int alsa_mute_raw(struct aml_audio_dec* audec, adec_bool_t en){
+
+    if(audec->aout_ops.private_data_raw) {
+        alsa_param_t *alsa_params = (alsa_param_t *)audec->aout_ops.private_data_raw;
+    } else {
+        adec_print("OUT SETTING::PCM\n");
+        return -1;
+    }
+
+    return 0;
+}
+
+#if 0
+/**
+ * \brief get output handle
+ * \param audec pointer to audec
+ */
+void get_output_func(struct aml_audio_dec* audec)
+{
+    audio_out_operations_t *out_ops = &audec->aout_ops;
+
+    out_ops->init = alsa_init_raw;
+    out_ops->start = alsa_start_raw;
+    out_ops->pause = alsa_pause_raw;
+    out_ops->resume = alsa_resume_raw;
+    out_ops->stop = alsa_stop_raw;
+    out_ops->latency = alsa_latency_raw;
+    out_ops->mute = alsa_mute_raw;
+}
+#endif
+
diff --git a/amadec/audio_out/alsa-out-raw.h b/amadec/audio_out/alsa-out-raw.h
new file mode 100644
index 0000000..c5725b3
--- /dev/null
+++ b/amadec/audio_out/alsa-out-raw.h
@@ -0,0 +1,19 @@
+#ifndef ALSA_OUT_RAW_H
+#define ALSA_OUT_RAW_H
+
+
+
+int alsa_get_aml_card();
+int alsa_get_spdif_port();
+int alsa_swtich_port(alsa_param_t *alsa_params, int card, int port);
+int alsa_init_raw(struct aml_audio_dec* audec);
+int alsa_start_raw(struct aml_audio_dec* audec);
+int alsa_pause_raw(struct aml_audio_dec* audec);
+int alsa_resume_raw(struct aml_audio_dec* audec);
+int alsa_stop_raw(struct aml_audio_dec* audec);
+int dummy_alsa_control_raw(char * id_string , long vol, int rw, long * value);
+int alsa_mute_raw(struct aml_audio_dec* audec, adec_bool_t en);
+
+
+#endif
+
diff --git a/amadec/audio_out/alsa-out.c b/amadec/audio_out/alsa-out.c
index fac816a..99ecc16 100755
--- a/amadec/audio_out/alsa-out.c
+++ b/amadec/audio_out/alsa-out.c
@@ -22,6 +22,11 @@
 #include <log-print.h>
 #include <alsa-out.h>
 #include "alsactl_parser.h"
+#include "alsa-out-raw.h"
+
+#define adec_print printf
+//#define adec_print
+
 
 #define   PERIOD_SIZE  1024
 #define   PERIOD_NUM    4
@@ -38,6 +43,10 @@ static snd_pcm_uframes_t chunk_size = PERIOD_SIZE;
 static char output_buffer[64 * 1024];
 static unsigned char decode_buffer[OUTPUT_BUFFER_SIZE + 64];
 
+static char sound_card_dev[10] = {0};
+
+int alsa_pause(struct aml_audio_dec* audec);
+
 #ifdef USE_INTERPOLATION
 static int pass1_history[8][8];
 #pragma align_to(64,pass1_history)
@@ -126,7 +135,7 @@ static int set_params(alsa_param_t *alsa_params)
     //  unsigned int period_time = 0;
     //  unsigned int buffer_time = 0;
     snd_pcm_uframes_t bufsize;
-    int err;
+    int err = 0;
     unsigned int rate;
     snd_pcm_uframes_t start_threshold, stop_threshold;
     snd_pcm_hw_params_alloca(&hwparams);
@@ -212,7 +221,7 @@ static int set_params(alsa_param_t *alsa_params)
         adec_print("Unable to get buffersize \n");
         return err;
     }
-	printf("alsa buffer frame size %d \n",bufsize);
+    printf("alsa buffer frame size %d \n",bufsize);
     alsa_params->buffer_size = bufsize * alsa_params->bits_per_frame / 8;
 
 #if 1
@@ -470,9 +479,9 @@ static void *alsa_playback_loop(void *args)
 
     pthread_mutex_lock(&alsa_params->playback_mutex);
     
-    while( !alsa_params->wait_flag )	
+    while( !alsa_params->wait_flag && alsa_params->stop_flag == 0)	
     {
-        adec_print("yvonnepthread_cond_wait\n");
+        adec_print("pthread_cond_wait\n");
          pthread_cond_wait(&alsa_params->playback_cond, &alsa_params->playback_mutex);
     }
     alsa_params->wait_flag=1;
@@ -490,10 +499,21 @@ static void *alsa_playback_loop(void *args)
             offset = 0;
         }
 
-        while (alsa_params->pause_flag) {
+        if (audec->state == GAPPING) {
+            adec_print(" ****************** audio callback blocked by gapping");
+            alsa_pause(audec);
+            alsa_params->pause_flag = 1;
+        }
+
+        while ((alsa_params->pause_flag) && (!alsa_params->stop_flag)) {
+            adec_refresh_pts(audec);
             usleep(10000);
         }
 
+        if (alsa_params->stop_flag)
+            break;
+
+
         adec_refresh_pts(audec);
 
         len2 = alsa_play(alsa_params, (buffer + offset), len);
@@ -520,10 +540,13 @@ int alsa_init(struct aml_audio_dec* audec)
 {
     adec_print("alsa out init");
 
-    int err;
+    int err = 0;
     pthread_t tid;
     alsa_param_t *alsa_param;
     audio_out_operations_t *out_ops = &audec->aout_ops;
+    int sound_card_id = 0;
+    int sound_dev_id = 0;
+    int dgraw = amsysfs_get_sysfs_int("/sys/class/audiodsp/digital_raw");
 
     alsa_param = (alsa_param_t *)malloc(sizeof(alsa_param_t));
     if (!alsa_param) {
@@ -605,10 +628,45 @@ int alsa_init(struct aml_audio_dec* audec)
     memset(pass2_history, 0, 64 * sizeof(int));
 #endif
 
-    err = snd_pcm_open(&alsa_param->handle, PCM_DEVICE_DEFAULT, SND_PCM_STREAM_PLAYBACK, 0);
+    if(((AUDIO_SPDIF_PASSTHROUGH == dgraw)||(AUDIO_HDMI_PASSTHROUGH == dgraw))&& \
+        ((ACODEC_FMT_AC3 == audec->format) || (ACODEC_FMT_EAC3 == audec->format))){
+
+        sound_card_id = alsa_get_aml_card();
+        if (sound_card_id  < 0) {
+            sound_card_id = 0;
+            adec_print("[%s::%d]--[get aml card fail, use default]\n",__FUNCTION__, __LINE__);
+        }
+        adec_print("[%s::%d]--[alsa_get_aml_card return:%d]\n",__FUNCTION__, __LINE__,sound_card_id);
+
+        sound_dev_id = alsa_get_spdif_port();
+        if (sound_dev_id < 0) {
+            sound_dev_id = 0;
+            adec_print("[%s::%d]--[get aml card device fail, use default]\n",__FUNCTION__, __LINE__);
+        }
+
+        adec_print("[%s::%d]--[sound_dev_id(spdif) return :%d]\n",__FUNCTION__, __LINE__,sound_dev_id);
+
+        if(0 == sound_dev_id) {
+            sound_dev_id = 1;
+        } else if(1 == sound_dev_id){
+            sound_dev_id = 0;
+        }
+        adec_print("[%s::%d]--[sound_dev_id convert to(pcm):%d]\n",__FUNCTION__, __LINE__,sound_dev_id);
+
+        sprintf(sound_card_dev, "hw:%d,%d", sound_card_id, sound_dev_id);
+    }else {
+        memcpy(sound_card_dev, PCM_DEVICE_DMIX, sizeof(PCM_DEVICE_DMIX));
+        amsysfs_set_sysfs_int("/sys/class/audiodsp/digital_codec",0);//set output codec type as pcm
+    }
+    adec_print("[%s::%d]--[sound_card_dev:%s]\n",__FUNCTION__, __LINE__,sound_card_dev);
+
+
+    err = snd_pcm_open(&alsa_param->handle, sound_card_dev, SND_PCM_STREAM_PLAYBACK, 0);
     if (err < 0) {
-        adec_print("audio open error: %s", snd_strerror(err));
+        adec_print("[%s::%d]--[audio open error: %s]\n", __FUNCTION__, __LINE__,snd_strerror(err));
         return -1;
+    } else {
+        adec_print("[%s::%d]--[audio open(snd_pcm_open) successfully]\n", __FUNCTION__, __LINE__);
     }
 
 
@@ -634,7 +692,22 @@ int alsa_init(struct aml_audio_dec* audec)
 
     alsa_param->playback_tid = tid;
 
-   alsactl_parser();
+    alsactl_parser();
+
+    //ac3 and eac3 passthrough
+    if(((AUDIO_SPDIF_PASSTHROUGH == dgraw)||(AUDIO_HDMI_PASSTHROUGH == dgraw)) && \
+        ((ACODEC_FMT_AC3 == audec->format) || (ACODEC_FMT_EAC3 == audec->format)) ){
+
+        int err;
+        err = alsa_init_raw(audec);
+        if (err != 0) {
+            adec_print("alsa_init_raw return error:%d\n", err);
+            snd_pcm_close(alsa_param->handle);
+            return -1;
+        }
+
+    }
+
     return 0;
 }
 
@@ -651,13 +724,24 @@ int alsa_start(struct aml_audio_dec* audec)
 
     audio_out_operations_t *out_ops = &audec->aout_ops;
     alsa_param_t *alsa_param = (alsa_param_t *)out_ops->private_data;
+    int dgraw = amsysfs_get_sysfs_int("/sys/class/audiodsp/digital_raw");
 
     pthread_mutex_lock(&alsa_param->playback_mutex);
-    adec_print("yvonne pthread_cond_signalalsa_param->wait_flag=1\n");
+    //adec_print("yvonne pthread_cond_signalalsa_param->wait_flag=1\n");
     alsa_param->wait_flag=1;//yvonneadded
+    alsa_param->pause_flag=1;
     pthread_cond_signal(&alsa_param->playback_cond);
     pthread_mutex_unlock(&alsa_param->playback_mutex);
 
+    //ac3 and eac3 passthrough
+    if(((AUDIO_SPDIF_PASSTHROUGH == dgraw)||(AUDIO_HDMI_PASSTHROUGH == dgraw)) && \
+        ((ACODEC_FMT_AC3 == audec->format) || (ACODEC_FMT_EAC3 == audec->format)) ) {
+        int err = alsa_start_raw(audec);
+        if(err) {
+            printf("alsa_start_raw return  error: %d\n", err);
+        }
+    }
+
     return 0;
 }
 
@@ -670,8 +754,9 @@ int alsa_pause(struct aml_audio_dec* audec)
 {
     adec_print("alsa out pause\n");
 
-    int res;
+    int res = 0;
     alsa_param_t *alsa_params;
+    int dgraw = amsysfs_get_sysfs_int("/sys/class/audiodsp/digital_raw");
 
     alsa_params = (alsa_param_t *)audec->aout_ops.private_data;
 
@@ -680,6 +765,16 @@ int alsa_pause(struct aml_audio_dec* audec)
         sleep(1);
     }
 
+    //ac3 and eac3 passthrough
+    if(((AUDIO_SPDIF_PASSTHROUGH == dgraw)||(AUDIO_HDMI_PASSTHROUGH == dgraw)) && \
+        ((ACODEC_FMT_AC3 == audec->format) || (ACODEC_FMT_EAC3 == audec->format)) ) {
+        int err = alsa_pause_raw(audec);
+        if(err) {
+            printf("alsa_pause_raw return  error: %d\n", err);
+        }
+    }
+
+
     return res;
 }
 
@@ -690,11 +785,21 @@ int alsa_pause(struct aml_audio_dec* audec)
  */
 int alsa_resume(struct aml_audio_dec* audec)
 {
-    adec_print("alsa out rsume\n");
+    adec_print("alsa out resume\n");
 
-    int res;
+    int res = 0;
     alsa_param_t *alsa_params;
 
+    //ac3 and eac3 passthrough
+    int dgraw = amsysfs_get_sysfs_int("/sys/class/audiodsp/digital_raw");
+    if(((AUDIO_SPDIF_PASSTHROUGH == dgraw)||(AUDIO_HDMI_PASSTHROUGH == dgraw)) && \
+        ((ACODEC_FMT_AC3 == audec->format) || (ACODEC_FMT_EAC3 == audec->format)) ) {
+        int err = alsa_resume_raw(audec);
+        if(err) {
+              printf("alsa_resume_raw return  error: %d\n", err);
+        }
+    }
+
     alsa_params = (alsa_param_t *)audec->aout_ops.private_data;
 
     alsa_params->pause_flag = 0;
@@ -712,14 +817,37 @@ int alsa_resume(struct aml_audio_dec* audec)
  */
 int alsa_stop(struct aml_audio_dec* audec)
 {
-    adec_print("enter alsa out stop\n");
+    int dgraw = amsysfs_get_sysfs_int("/sys/class/audiodsp/digital_raw");
 
+    int res = 0;
     alsa_param_t *alsa_params;
 
     alsa_params = (alsa_param_t *)audec->aout_ops.private_data;
+    adec_print("[%s::%d] in--[alsa_params:0x%x]\n",__FUNCTION__, __LINE__,alsa_params);
+
+    //resume the spdif card, otherwise the output will block
+    if(alsa_params->pause_flag == 1){
+        while ((res = snd_pcm_pause(alsa_params->handle, 0)) == -EAGAIN) {
+            usleep(1000);
+        }
+    }
+
+    //exit alsa_playback_loop
     alsa_params->pause_flag = 0; //we should clear pause flag ,as we can stop from paused state
     alsa_params->stop_flag = 1;
     alsa_params->wait_flag = 0;
+
+    //ac3 and eac3 passthrough
+    if(((AUDIO_SPDIF_PASSTHROUGH == dgraw)||(AUDIO_HDMI_PASSTHROUGH == dgraw)) && \
+        ((ACODEC_FMT_AC3 == audec->format) || (ACODEC_FMT_EAC3 == audec->format)) ) {
+
+        adec_print("enter alsa_stop_raw step\n");
+        int err = alsa_stop_raw(audec);
+        if(err) {
+            printf("alsa_stop_raw return  error: %d\n", err);
+        }
+    }
+
     pthread_cond_signal(&alsa_params->playback_cond);
     pthread_join(alsa_params->playback_tid, NULL);
     pthread_mutex_destroy(&alsa_params->playback_mutex);
@@ -739,7 +867,7 @@ int alsa_stop(struct aml_audio_dec* audec)
 static int alsa_get_space(alsa_param_t * alsa_param)
 {
     snd_pcm_status_t *status;
-    int ret;
+    int ret = 0;
 
     snd_pcm_status_alloca(&status);
     if ((ret = snd_pcm_status(alsa_param->handle, status)) < 0) {
@@ -773,7 +901,7 @@ unsigned long alsa_latency(struct aml_audio_dec* audec)
 * alsa dumy codec controls interface
 */
 int dummy_alsa_control(char * id_string , long vol, int rw, long * value){
-    int err;
+    int err = 0;
     snd_hctl_t *hctl;
     snd_ctl_elem_id_t *id;
     snd_hctl_elem_t *elem;
@@ -783,12 +911,12 @@ int dummy_alsa_control(char * id_string , long vol, int rw, long * value){
     unsigned int idx = 0, count;
     long tmp, min, max;
 
-    if ((err = snd_hctl_open(&hctl, PCM_DEVICE_DEFAULT, 0)) < 0) { 
-        printf("Control %s open error: %s\n", PCM_DEVICE_DEFAULT, snd_strerror(err));
+    if ((err = snd_hctl_open(&hctl, sound_card_dev, 0)) < 0) { 
+        printf("Control %s open error: %s\n", sound_card_dev, snd_strerror(err));
         return err;
     }
     if (err = snd_hctl_load(hctl)< 0) {
-        printf("Control %s open error: %s\n", PCM_DEVICE_DEFAULT, snd_strerror(err));
+        printf("Control %s open error: %s\n", sound_card_dev, snd_strerror(err));
         return err;
     }
     snd_ctl_elem_id_alloca(&id);
@@ -799,8 +927,8 @@ int dummy_alsa_control(char * id_string , long vol, int rw, long * value){
     snd_ctl_elem_value_set_id(control, id);
     snd_ctl_elem_info_alloca(&info);
     if ((err = snd_hctl_elem_info(elem, info)) < 0) {
-        printf("Control %s snd_hctl_elem_info error: %s\n", PCM_DEVICE_DEFAULT, snd_strerror(err));
-		    return err;
+        printf("Control %s snd_hctl_elem_info error: %s\n", sound_card_dev, snd_strerror(err));
+        return err;
     }    
     count = snd_ctl_elem_info_get_count(info);
     type = snd_ctl_elem_info_get_type(info);
@@ -838,7 +966,7 @@ int dummy_alsa_control(char * id_string , long vol, int rw, long * value){
 	        break;
         }
         if (err < 0){
-            printf ("control%s access error=%s,close control device\n", PCM_DEVICE_DEFAULT, snd_strerror(err));
+            printf ("control%s access error=%s,close control device\n", sound_card_dev, snd_strerror(err));
             snd_hctl_close(hctl);
             return err;
         }
@@ -853,7 +981,19 @@ int dummy_alsa_control(char * id_string , long vol, int rw, long * value){
  * \return 0 on success otherwise negative error code
  */
 static int alsa_mute(struct aml_audio_dec* audec, adec_bool_t en){
-	return 0;
+
+    int dgraw = amsysfs_get_sysfs_int("/sys/class/audiodsp/digital_raw");
+
+    //ac3 and eac3 passthrough
+    if(((AUDIO_SPDIF_PASSTHROUGH == dgraw)||(AUDIO_HDMI_PASSTHROUGH == dgraw)) && \
+    ((ACODEC_FMT_AC3 == audec->format) || (ACODEC_FMT_EAC3 == audec->format)) ) {
+        int err = alsa_mute_raw(audec,en);
+        if(err) {
+            adec_print("alsa_mute_raw return  error: %d\n", err);
+        }
+    }
+
+    return 0;
 }
 /**
  * \brief get output handle
diff --git a/amadec/audio_out/android-out.cpp b/amadec/audio_out/android-out.cpp
index beef655..b022e1d 100755
--- a/amadec/audio_out/android-out.cpp
+++ b/amadec/audio_out/android-out.cpp
@@ -28,10 +28,16 @@ extern "C" {
 #include <Amsysfsutils.h>
 }
 
+//#define DUMP_PCM
+
 namespace android
 {
 
 static Mutex mLock;
+#ifdef DUMP_PCM
+static int mDumpPcmFd = -1;
+#endif
+extern "C" int android_pause(struct aml_audio_dec* audec);
 static int get_digitalraw_mode(void)
 {
     int fd;
@@ -222,6 +228,12 @@ void audioCallback(int event, void* user, void *info)
       adec_refresh_pts(audec);
     }
 
+    if (audec->state == GAPPING) {
+        adec_print(" ****************** audio callback blocked by gapping");
+        android_pause(audec);
+        return;
+    }
+
     if(wfd_enable){
       // filtering
       diff_record[diff_wp++] = diff;
@@ -275,6 +287,13 @@ void audioCallback(int event, void* user, void *info)
         af_resample_api_normal((char*)(buffer->i16), &buffer->size, buffer->channelCount, audec);
         #endif 
       }
+	  
+#ifdef DUMP_PCM
+		if (mDumpPcmFd >= 0) {
+            write(mDumpPcmFd, buffer->i16, buffer->size);
+        }
+#endif
+	  
      } else {
         adec_print("audioCallback: dsp not work!\n");
     }
@@ -511,7 +530,10 @@ extern "C" int android_init_raw(struct aml_audio_dec* audec)
  */
 extern "C" int android_init(struct aml_audio_dec* audec)
 {
-   
+#ifdef DUMP_PCM
+    static int aidx = 0;
+    char afn[32];
+#endif
     
     status_t status;
     AudioTrack *track;
@@ -644,6 +666,10 @@ extern "C" int android_init(struct aml_audio_dec* audec)
     }
     af_resample_linear_init();
     out_ops->private_data = (void *)track;
+#ifdef DUMP_PCM
+    sprintf(afn, "/tmp/aout" "_%d.pcm", aidx++);
+    mDumpPcmFd = open(afn, O_WRONLY | O_CREAT, 0644);
+#endif
     return 0;
 }
 #ifdef USE_ARM_AUDIO_DEC
@@ -665,8 +691,9 @@ extern "C" int android_start_raw(struct aml_audio_dec* audec)
            return -1;
     }
     
-    track->start();
-    adec_print("[%s %d]AudioTrack_raw initCheck OK and started.",__FUNCTION__,__LINE__);
+    //track->start();
+    //adec_print("[%s %d]AudioTrack_raw initCheck OK and started.",__FUNCTION__,__LINE__);
+    adec_print("[%s %d]AudioTrack_raw initCheck OK.",__FUNCTION__,__LINE__);
     return 0;
 }
 #endif
@@ -707,8 +734,9 @@ extern "C" int android_start(struct aml_audio_dec* audec)
         out_ops->private_data = NULL;
         return -1;
     }
-    track->start();
-    adec_print("AudioTrack initCheck OK and started.");
+    //track->start();
+    //adec_print("AudioTrack initCheck OK and started.");
+    adec_print("AudioTrack initCheck OK.");
     
     return 0;
 }
@@ -852,6 +880,11 @@ extern "C" int android_stop(struct aml_audio_dec* audec)
     restore_system_samplerate();	
 
     restore_system_framesize();
+#ifdef DUMP_PCM
+    if (mDumpPcmFd >= 0) {
+        close(mDumpPcmFd);
+    }
+#endif
 
     return 0;
 }
@@ -865,6 +898,7 @@ extern "C" unsigned long android_latency(struct aml_audio_dec* audec)
 {
     unsigned long latency;
     audio_out_operations_t *out_ops = &audec->aout_ops;
+#if 0
     AudioTrack *track = (AudioTrack *)out_ops->private_data;
 
     if (track) {
@@ -873,6 +907,8 @@ extern "C" unsigned long android_latency(struct aml_audio_dec* audec)
     }
 
     return 0;
+#endif
+    return 100;
 }
 #ifndef ANDROID_VERSION_JBMR2_UP
 /**
diff --git a/amadec/audiodsp_update_format.c b/amadec/audiodsp_update_format.c
index 5332fb2..2c58f38 100755
--- a/amadec/audiodsp_update_format.c
+++ b/amadec/audiodsp_update_format.c
@@ -95,14 +95,17 @@ void adec_reset_track(aml_audio_dec_t *audec)
         adec_print("reset audio_track: samplerate=%d channels=%d\n", audec->samplerate,audec->channels);
         audio_out_operations_t *out_ops = &audec->aout_ops;
         out_ops->mute(audec, 1);
-        out_ops->pause(audec);
+		//out_ops->pause(audec);//otherwise will block indefinitely at the writei_func in func pcm_write
         out_ops->stop(audec);
         //audec->SessionID +=1;
         out_ops->init(audec);
-        if(audec->state == ACTIVE)
-        	out_ops->start(audec);
-        audec->format_changed_flag=0;
-    }
+        if(audec->state == ACTIVE) {
+            out_ops->start(audec);
+            out_ops->resume(audec);
+        }
+
+	    audec->format_changed_flag=0;
+	}
 }
 
 int audiodsp_format_update(aml_audio_dec_t *audec)
diff --git a/amadec/include/adec-external-ctrl.h b/amadec/include/adec-external-ctrl.h
index 21757c7..9649882 100755
--- a/amadec/include/adec-external-ctrl.h
+++ b/amadec/include/adec-external-ctrl.h
@@ -26,6 +26,8 @@ extern "C"
     int audio_decode_set_mute(void *handle, int);
     int audio_decode_set_volume(void *, float);
     int audio_decode_get_volume(void *, float *);
+    int audio_decode_set_volume_ease(void *, float, unsigned int, int);
+    int audio_decode_get_volume_ease(void *, float *, unsigned int *);
     int audio_channels_swap(void *);
     int audio_channel_left_mono(void *);
     int audio_channel_right_mono(void *);
diff --git a/amadec/include/adec-types.h b/amadec/include/adec-types.h
index f531474..8c62e5e 100755
--- a/amadec/include/adec-types.h
+++ b/amadec/include/adec-types.h
@@ -49,6 +49,7 @@ typedef enum {
     INITTED,
     ACTIVE,
     PAUSED,
+    GAPPING,
 } adec_state_t;
 
 #endif
diff --git a/amadec/include/alsa-out.h b/amadec/include/alsa-out.h
index bb6c56b..ad424d4 100755
--- a/amadec/include/alsa-out.h
+++ b/amadec/include/alsa-out.h
@@ -2,6 +2,8 @@
 #define ALSA_OUT_H
 
 #define PCM_DEVICE_DEFAULT      "default"
+#define PCM_DEVICE_DMIX         "dmix"
+
 #define OUTPUT_BUFFER_SIZE      (8*1024)
 
 typedef struct {
diff --git a/amadec/include/log-print.h b/amadec/include/log-print.h
index af5fab4..49c1787 100755
--- a/amadec/include/log-print.h
+++ b/amadec/include/log-print.h
@@ -11,6 +11,8 @@
 #ifndef LOG_PRINT_H
 #define LOG_PRINT_H
 
+#define adec_print printf
+#if 0
 #ifdef ANDROID
 #include <android/log.h>
 #include <stdio.h>
@@ -26,6 +28,6 @@ char *level;
 						   fprintf(stderr,f,##s);\
 						   else; }while(0);
 #endif
-
+#endif
 
 #endif
diff --git a/amavutils/Makefile b/amavutils/Makefile
index 5895900..765498c 100644
--- a/amavutils/Makefile
+++ b/amavutils/Makefile
@@ -1,8 +1,8 @@
 TARGET = libamavutils.so
 
-TARGET_OBJS=amaudioutils.o amconfigutils.o amdisplayutils.o ammodule.o amsysfsutils.o Amvideoutils.o itemlist.o\
+TARGET_OBJS=amaudioutils.o amconfigutils.o amdisplayutils.o ammodule.o amsysfsutils.o Amvideoutils.o itemlist.o amdrmutils.o
 
-LDFLAGS += -shared -lm -lrt
+LDFLAGS += -shared -lpthread -lm -lrt
 
 TARGET_DIR=$(shell pwd)/../../../target
 STAGING_DIR=$(shell pwd)/../../../staging
@@ -12,14 +12,14 @@ CFLAGS+=-I$(shell pwd) -I$(shell pwd)/include -I$(shell pwd)/../amcodec/include
 
 export CC CFLAGS
 
-all: $(TARGET) 
+all: $(TARGET)
 
 $(TARGET): $(TARGET_OBJS)
 	echo "CC=$(CC)"
 	echo "LD=$(LD)"
 	echo "CFLAGS=$(CFLAGS)"
 	echo "LDFLAGS=$(LDFLAGS)"
-	$(CC) $(CFLAGS) $(LDFLAGS) $(TARGET_OBJS:%.o=%.c) -o $@  
+	$(CC) $(CFLAGS) $(LDFLAGS) $(TARGET_OBJS:%.o=%.c) -o $@
 
 clean:
 	-rm -rf *.o $(TARGET)
\ No newline at end of file
diff --git a/amavutils/amdrmutils.c b/amavutils/amdrmutils.c
new file mode 100644
index 0000000..b2dbb74
--- /dev/null
+++ b/amavutils/amdrmutils.c
@@ -0,0 +1,152 @@
+
+#define LOG_TAG "amdrmutils"
+
+#include <stdlib.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <strings.h>
+#include <cutils/log.h>
+#include <cutils/properties.h>
+#include <sys/ioctl.h>
+#include "include/Amsyswrite.h"
+#include "include/amdrmutils.h"
+
+#define TVP_ENABLE_PATH     "/sys/class/codec_mm/tvp_enable"
+#define TVP_REGION_PATH     "/sys/class/codec_mm/tvp_region"
+#define FREE_KEEP_BUFFER_PATH   "/sys/class/video/free_keep_buffer"
+#define VFM_DEF_MAP_PATH    "/sys/class/vfm/map"
+#define DI_TVP_REGION_PATH  "/sys/class/deinterlace/di0/tvp_region"
+#define DISABLE_VIDEO_PATH  "/sys/class/video/disable_video"
+
+#ifndef LOGD
+#define LOGV ALOGV
+#define LOGD ALOGD
+#define LOGI ALOGI
+#define LOGW ALOGW
+#define LOGE ALOGE
+#endif
+
+//#define LOG_FUNCTION_NAME LOGI("%s-%d\n",__FUNCTION__,__LINE__);
+#define LOG_FUNCTION_NAME
+#define BUF_LEN 512
+#define MAX_REGION 6
+
+int set_tvp_enable(int enable)
+{
+    int fd;
+    char bcmd[16];
+    fd = open(TVP_ENABLE_PATH, O_CREAT | O_RDWR | O_TRUNC, 0644);
+    if (fd >= 0) {
+        sprintf(bcmd, "%d", enable);
+        write(fd, bcmd, strlen(bcmd));
+        close(fd);
+        return 0;
+    }
+
+    return -1;
+}
+
+int free_keep_buffer(void)
+{
+    int fd;
+    char bcmd[16];
+    fd = open(FREE_KEEP_BUFFER_PATH, O_CREAT | O_RDWR | O_TRUNC, 0644);
+    if (fd >= 0) {
+        sprintf(bcmd, "%d", 1);
+        write(fd, bcmd, strlen(bcmd));
+        close(fd);
+        return 0;
+    }
+
+    return -1;
+}
+
+int set_vfmmap_ppmgr_di(int enable)
+{
+    int fd;
+    char bcmd[128];
+    fd = open(VFM_DEF_MAP_PATH, O_CREAT | O_RDWR | O_TRUNC, 0644);
+    if (fd >= 0) {
+        sprintf(bcmd, "rm default");
+        write(fd, bcmd, strlen(bcmd));
+        if (enable)
+            sprintf(bcmd, "add default decoder ppmgr deinterlace amvideo");
+        else
+            sprintf(bcmd, "add default decoder amvideo");
+        write(fd, bcmd, strlen(bcmd));
+        close(fd);
+        return 0;
+    }
+    return -1;
+}
+
+int set_disable_video(int mode)
+{
+    int fd;
+    char  bcmd[16];
+    fd = open(DISABLE_VIDEO_PATH, O_CREAT | O_RDWR | O_TRUNC, 0644);
+    if (fd >= 0) {
+        sprintf(bcmd, "%d", mode);
+        write(fd, bcmd, strlen(bcmd));
+        close(fd);
+        return 0;
+    }
+
+    return -1;
+}
+
+int tvp_mm_enable(int flags)
+{
+    //flags: bit 1---4k ;
+    int is_4k= flags &TVP_MM_ENABLE_FLAGS_FOR_4K;
+    free_keep_buffer();
+    //set_vfmmap_ppmgr_di(0);
+    if (is_4k)
+        set_tvp_enable(2);
+    else
+        set_tvp_enable(1);
+    return 0;
+
+}
+
+int tvp_mm_disable(int flags)
+{
+    set_disable_video(0);
+    free_keep_buffer();
+    //set_vfmmap_ppmgr_di(1);
+    set_tvp_enable(0);
+    /*unused flags*/
+    return 0;
+}
+
+int tvp_mm_get_mem_region(struct tvp_region* region, int region_size)
+{
+    int fd, len;
+    char buf[BUF_LEN];
+    unsigned int n=0, i=0, rnum = 0, siz;
+    unsigned long long start=0, end=0;
+
+    //rnum = min(region_size/sizeof(struct tvp_region), MAX_REGION);
+    rnum = region_size/sizeof(struct tvp_region);
+
+    fd = open(TVP_REGION_PATH, O_RDONLY, 0644);
+    if (fd >= 0) {
+        len = read(fd, buf, BUF_LEN);
+        close(fd);
+        for (i=0,n=0; (n < len) && (i < rnum); i++, region++) {
+            if (4 == sscanf(buf+n, "segment%d:%llx - %llx (size:%x)",
+                    &i, &start, &end, &siz))
+            {
+                //ALOGE("segment %d: [%llx-%llx]\n", i, start, end);
+                region->start = start;
+                region->end = end;
+                region->mem_flags = 0;
+                n += strcspn(buf+n, "\n") + 1;
+            }
+        }
+        return i;
+    }
+    return -1;
+}
+
+
diff --git a/amavutils/amsysfsutils.c b/amavutils/amsysfsutils.c
index 4ba5134..582858a 100755
--- a/amavutils/amsysfsutils.c
+++ b/amavutils/amsysfsutils.c
@@ -31,7 +31,7 @@ int amsysfs_set_sysfs_str(const char *path, const char *val)
         close(fd);
         return 0;
     } else {
-        LOGE("unable to open file %s,err: %s", path, strerror(errno));
+        //LOGE("unable to open file %s,err: %s", path, strerror(errno));
     }
     return -1;
 }
@@ -45,7 +45,7 @@ int  amsysfs_get_sysfs_str(const char *path, char *valstr, int size)
         valstr[strlen(valstr)] = '\0';
         close(fd);
     } else {
-        LOGE("unable to open file %s,err: %s", path, strerror(errno));
+        //LOGE("unable to open file %s,err: %s", path, strerror(errno));
         sprintf(valstr, "%s", "fail");
         return -1;
     };
@@ -65,7 +65,7 @@ int amsysfs_set_sysfs_int(const char *path, int val)
         close(fd);
         return 0;
     } else {
-        LOGE("unable to open file %s,err: %s", path, strerror(errno));
+        //LOGE("unable to open file %s,err: %s", path, strerror(errno));
     }
     return -1;
 }
@@ -81,7 +81,7 @@ int amsysfs_get_sysfs_int(const char *path)
         val = strtol(bcmd, NULL, 10);
         close(fd);
     }else {
-        LOGE("unable to open file %s,err: %s", path, strerror(errno));
+        //LOGE("unable to open file %s,err: %s", path, strerror(errno));
     }
     return val;
 }
@@ -98,7 +98,7 @@ int amsysfs_set_sysfs_int16(const char *path, int val)
         close(fd);
         return 0;
     } else {
-        LOGE("unable to open file %s,err: %s", path, strerror(errno));
+        //LOGE("unable to open file %s,err: %s", path, strerror(errno));
     }
     
     return -1;
@@ -115,7 +115,7 @@ int amsysfs_get_sysfs_int16(const char *path)
         val = strtol(bcmd, NULL, 16);
         close(fd);
     } else {
-        LOGE("unable to open file %s,err: %s", path, strerror(errno));
+        //LOGE("unable to open file %s,err: %s", path, strerror(errno));
     }
     return val;
 }
@@ -130,7 +130,7 @@ unsigned long amsysfs_get_sysfs_ulong(const char *path)
     	num = strtoul(bcmd, NULL, 0);
     	close(fd);
 	} else {
-        LOGE("unable to open file %s,err: %s", path, strerror(errno));
+        //LOGE("unable to open file %s,err: %s", path, strerror(errno));
     }
 	return num;
 }
diff --git a/amavutils/include/amdrmutils.h b/amavutils/include/amdrmutils.h
new file mode 100644
index 0000000..0c378db
--- /dev/null
+++ b/amavutils/include/amdrmutils.h
@@ -0,0 +1,27 @@
+#ifndef AMDRM_UTILS_H
+#define AMDRM_UTILS_H
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+struct tvp_region
+{
+	unsigned long long start;
+	unsigned long long end;
+	int mem_flags;
+};
+
+#define TVP_MM_ENABLE_FLAGS_FOR_4K 0x02
+
+extern int tvp_mm_enable(int flags);
+extern int tvp_mm_disable(int flags);
+extern int tvp_mm_get_mem_region(struct tvp_region* region, int region_size);
+
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/amcodec/audio_ctl/audio_ctrl.c b/amcodec/audio_ctl/audio_ctrl.c
index 04c66e9..7e1ec4c 100755
--- a/amcodec/audio_ctl/audio_ctrl.c
+++ b/amcodec/audio_ctl/audio_ctrl.c
@@ -202,6 +202,45 @@ int codec_get_volume(codec_para_t *p, float *val)
 
 /* --------------------------------------------------------------------------*/
 /**
+* @brief  codec_set_volume  Set audio volume
+*
+* @param[in]  p    Pointer of codec parameter structure
+* @param[in]  val  Target volume to be set
+* @param[in]  duration Time needed to set target volume in millisecond unit
+* @param[in]  method The method for easing effect:
+*             0:EaseLinear, 1:EaseInCubic, 2:EaseOutCubic
+*
+* @return     command result
+*/
+/* --------------------------------------------------------------------------*/
+int codec_set_volume_ease(codec_para_t *p, float val, unsigned int duration, int method)
+{
+    int ret;
+
+    ret = audio_decode_set_volume_ease(p->adec_priv, val, duration, method);
+    return ret;
+}
+
+/* --------------------------------------------------------------------------*/
+/**
+* @brief  codec_get_volume_ease  Get audio volume
+*
+* @param[in]  p   Pointer of codec parameter structure
+* @param[out] val Pointer of returned valume (changing during ease operation)
+* @param[out] duration Pointer of remaining MS time needed for ease operation
+*
+* @return     command result
+*/
+/* --------------------------------------------------------------------------*/
+int codec_get_volume_ease(codec_para_t *p, float *val, unsigned int *duration)
+{
+    int ret;
+    ret = audio_decode_get_volume_ease(p->adec_priv, val, duration);
+    return ret;
+}
+
+/* --------------------------------------------------------------------------*/
+/**
 * @brief  codec_set_volume  Set audio volume seperately
 *
 * @param[in]  p    Pointer of codec parameter structure
diff --git a/amcodec/codec/codec_ctrl.c b/amcodec/codec/codec_ctrl.c
index 99d56f1..61343c4 100755
--- a/amcodec/codec/codec_ctrl.c
+++ b/amcodec/codec/codec_ctrl.c
@@ -40,14 +40,14 @@
 */
 /* --------------------------------------------------------------------------*/
 static int codec_set_demux_source(codec_para_t *pcodec, int source)
-{    
-    int ret = 0;		
-	
-    ret = codec_h_control(pcodec->handle, AMSTREAM_IOC_SET_DEMUX, (unsigned long)source);
-	if (ret < 0) {
-		return ret;
-	}	
-    return ret;     
+{
+    int ret = 0;
+
+    ret = codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET, AMSTREAM_SET_DEMUX, (unsigned long)source);
+    if (ret < 0) {
+        return ret;
+    }
+    return ret;
 }
 
 /* --------------------------------------------------------------------------*/
@@ -63,13 +63,13 @@ static int codec_change_buf_size(codec_para_t *pcodec)
 {
     int r;
     if (pcodec->abuf_size > 0) {
-        r = codec_h_control(pcodec->handle, AMSTREAM_IOC_AB_SIZE, pcodec->abuf_size);
+        r = codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET, AMSTREAM_SET_AB_SIZE, pcodec->abuf_size);
         if (r < 0) {
             return system_error_to_codec_error(r);
         }
     }
     if (pcodec->vbuf_size > 0) {
-        r = codec_h_control(pcodec->handle, AMSTREAM_IOC_VB_SIZE, pcodec->vbuf_size);
+        r = codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET, AMSTREAM_SET_VB_SIZE, pcodec->vbuf_size);
         if (r < 0) {
             return system_error_to_codec_error(r);
         }
@@ -94,9 +94,9 @@ static  int set_video_format(codec_para_t *pcodec)
         return -CODEC_ERROR_VIDEO_TYPE_UNKNOW;
     }
 
-    r = codec_h_control(pcodec->handle, AMSTREAM_IOC_VFORMAT, format);
+    r = codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET, AMSTREAM_SET_VFORMAT, format);
     if (pcodec->video_pid >= 0) {
-        r = codec_h_control(pcodec->handle, AMSTREAM_IOC_VID, pcodec->video_pid);
+        r = codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET, AMSTREAM_SET_VID, pcodec->video_pid);
         if (r < 0) {
             return system_error_to_codec_error(r);
         }
@@ -146,14 +146,14 @@ static  int set_audio_format(codec_para_t *pcodec)
         return -CODEC_ERROR_AUDIO_TYPE_UNKNOW;
     }
 
-    r = codec_h_control(pcodec->handle, AMSTREAM_IOC_AFORMAT, format);
+    r = codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET, AMSTREAM_SET_AFORMAT, format);
     if (r < 0) {
         codec_r = system_error_to_codec_error(r);
         print_error_msg(codec_r, errno, __FUNCTION__, __LINE__);
         return codec_r;
     }
     if (pcodec->audio_pid >= 0) {
-        r = codec_h_control(pcodec->handle, AMSTREAM_IOC_AID, pcodec->audio_pid);
+        r = codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET, AMSTREAM_SET_AID, pcodec->audio_pid);
         if (r < 0) {
             codec_r = system_error_to_codec_error(r);
             print_error_msg(codec_r, errno, __FUNCTION__, __LINE__);
@@ -161,7 +161,7 @@ static  int set_audio_format(codec_para_t *pcodec)
         }
     }
     if (pcodec->audio_samplerate > 0) {
-        r = codec_h_control(pcodec->handle, AMSTREAM_IOC_SAMPLERATE, pcodec->audio_samplerate);
+        r = codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET, AMSTREAM_SET_SAMPLERATE, pcodec->audio_samplerate);
         if (r < 0) {
             codec_r = system_error_to_codec_error(r);
             print_error_msg(codec_r, errno, __FUNCTION__, __LINE__);
@@ -169,7 +169,7 @@ static  int set_audio_format(codec_para_t *pcodec)
         }
     }
     if (pcodec->audio_channels > 0) {
-        r = codec_h_control(pcodec->handle, AMSTREAM_IOC_ACHANNEL, pcodec->audio_channels);
+        r = codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET, AMSTREAM_SET_ACHANNEL, pcodec->audio_channels);
         if (r < 0) {
             codec_r = system_error_to_codec_error(r);
             print_error_msg(codec_r, errno, __FUNCTION__, __LINE__);
@@ -194,7 +194,7 @@ static int set_audio_info(codec_para_t *pcodec)
     int codec_r;
     audio_info_t *audio_info = &pcodec->audio_info;
     CODEC_PRINT("set_audio_info\n");
-    r = codec_h_control(pcodec->handle, AMSTREAM_IOC_AUDIO_INFO, (unsigned long)audio_info);
+    r = codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET_PTR, AMSTREAM_SET_PTR_AUDIO_INFO, (unsigned long)audio_info);
     if (r < 0) {
         codec_r = system_error_to_codec_error(r);
         print_error_msg(codec_r, errno, __FUNCTION__, __LINE__);
@@ -217,12 +217,12 @@ static int set_sub_format(codec_para_t *pcodec)
     int r;
 
     if (pcodec->sub_pid >= 0) {
-        r = codec_h_control(pcodec->handle, AMSTREAM_IOC_SID, pcodec->sub_pid);
+        r = codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET, AMSTREAM_SET_SID, pcodec->sub_pid);
         if (r < 0) {
             return system_error_to_codec_error(r);
         }
 
-        r = codec_h_control(pcodec->handle, AMSTREAM_IOC_SUB_TYPE, pcodec->sub_type);
+        r = codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET, AMSTREAM_SET_SUB_TYPE, pcodec->sub_type);
         if (r < 0) {
             return system_error_to_codec_error(r);
         }
@@ -250,13 +250,35 @@ static int set_ts_skip_byte(codec_para_t *pcodec)
         skip_byte = 0;
     }
 
-    r = codec_h_control(pcodec->handle, AMSTREAM_IOC_TS_SKIPBYTE, skip_byte);
+    r = codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET, AMSTREAM_SET_TS_SKIPBYTE, skip_byte);
     if (r < 0) {
         return system_error_to_codec_error(r);
     }
 
     return 0;
 }
+/* --------------------------------------------------------------------------*/
+/**
+* @brief  codec_check_new_cmd  Check new cmd for ioctl
+*
+*/
+/* --------------------------------------------------------------------------*/
+static inline void codec_check_new_cmd(CODEC_HANDLE handle)
+{
+    if (!codec_h_is_support_new_cmd()) {
+        int r;
+        int version = 0;
+        r = codec_h_control(handle, AMSTREAM_IOC_GET_VERSION, &version);
+        if ((r == 0) && (version >= 0x20000)) {
+            CODEC_PRINT("codec_init amstream version : %d.%d\n", (version & 0xffff0000) >> 16, version & 0xffff);
+            codec_h_set_support_new_cmd(1);
+        } else {
+            CODEC_PRINT("codec_init amstream use old cmd\n");
+            codec_h_set_support_new_cmd(0);
+        }
+
+    }
+}
 
 /* --------------------------------------------------------------------------*/
 /**
@@ -278,7 +300,7 @@ static inline int codec_video_es_init(codec_para_t *pcodec)
     }
 
     flags |= pcodec->noblock ? O_NONBLOCK : 0;
-    if(pcodec->video_type == VFORMAT_HEVC) {
+    if(pcodec->video_type == VFORMAT_HEVC || pcodec->video_type == VFORMAT_VP9) {
 		printf("OPEN es hevc\n");
       handle = codec_h_open(CODEC_VIDEO_ES_HEVC_DEVICE, flags);
     }
@@ -293,6 +315,9 @@ static inline int codec_video_es_init(codec_para_t *pcodec)
         return CODEC_OPEN_HANDLE_FAILED;
     }
     pcodec->handle = handle;
+
+    codec_check_new_cmd(handle);
+
     r = set_video_format(pcodec);
     if (r < 0) {
         codec_h_close(handle);
@@ -338,6 +363,9 @@ static inline int codec_audio_es_init(codec_para_t *pcodec)
         return CODEC_OPEN_HANDLE_FAILED;
     }
     pcodec->handle = handle;
+
+    codec_check_new_cmd(handle);
+
     r = set_audio_format(pcodec);
     if (r < 0) {
         codec_h_close(handle);
@@ -427,13 +455,17 @@ static inline int codec_ps_init(codec_para_t *pcodec)
         return CODEC_OPEN_HANDLE_FAILED;
     }
     pcodec->handle = handle;
+
+    codec_check_new_cmd(handle);
+
     if (pcodec->has_video) {
         r = set_video_format(pcodec);
         if (r < 0) {
             goto error1;
         }
         if ((pcodec->video_type == VFORMAT_H264)
-            || (pcodec->video_type == VFORMAT_VC1)){
+            || (pcodec->video_type == VFORMAT_VC1)
+            || (pcodec->video_type == VFORMAT_MPEG12)) {
             r = set_video_codec_info(pcodec);
             if (r < 0) {
                 /*codec_h_close(handle);
@@ -512,13 +544,16 @@ static inline int codec_ts_init(codec_para_t *pcodec)
         return CODEC_OPEN_HANDLE_FAILED;
     }
     pcodec->handle = handle;
+
+    codec_check_new_cmd(handle);
+
     codec_set_demux_source(pcodec, DEMUX_PLAYER_SOURCE);
     if (pcodec->has_video) {
         r = set_video_format(pcodec);
         if (r < 0) {
             goto error1;
         }
-        if ((pcodec->video_type == VFORMAT_H264) || (pcodec->video_type == VFORMAT_VC1)|| (pcodec->video_type == VFORMAT_AVS)) {
+        if ((pcodec->video_type == VFORMAT_H264) || (pcodec->video_type == VFORMAT_MPEG4) || (pcodec->video_type == VFORMAT_VC1) || (pcodec->video_type == VFORMAT_AVS) || (pcodec->video_type == VFORMAT_MPEG12)) {
             r = set_video_codec_info(pcodec);
             if (r < 0) {
                 codec_h_close(handle);
@@ -601,6 +636,9 @@ static inline int codec_rm_init(codec_para_t *pcodec)
     }
 
     pcodec->handle = handle;
+
+    codec_check_new_cmd(handle);
+
     if (pcodec->has_video) {
         r = set_video_format(pcodec);
         if (r < 0) {
@@ -649,6 +687,9 @@ int codec_init(codec_para_t *pcodec)
     pcodec->cntl_handle = -1;
     pcodec->sub_handle = -1;
     pcodec->audio_utils_handle = -1;
+    if (pcodec->audio_type == AFORMAT_MPEG1 || pcodec->audio_type == AFORMAT_MPEG2) {
+        pcodec->audio_type = AFORMAT_MPEG;
+    }
     switch (pcodec->stream_type) {
     case STREAM_TYPE_ES_VIDEO:
         ret = codec_video_es_init(pcodec);
@@ -683,8 +724,10 @@ int codec_init(codec_para_t *pcodec)
     if (ret != 0) {
         return -CODEC_ERROR_SET_BUFSIZE_FAILED;
     }
-    ret = codec_h_control(pcodec->handle, AMSTREAM_IOC_PORT_INIT, 0);
-    if (ret != 0) {        
+
+    ret = codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET, AMSTREAM_PORT_INIT, 0);
+    if (ret != 0) {
+
         return -CODEC_ERROR_INIT_FAILED;
     }
     
@@ -701,9 +744,11 @@ int codec_init(codec_para_t *pcodec)
         a_ainfo.bitrate    =pcodec->audio_info.bitrate;
         a_ainfo.block_align=pcodec->audio_info.block_align;
         a_ainfo.codec_id   =pcodec->audio_info.codec_id;
+        a_ainfo.automute   = pcodec->automute_flag;
+        a_ainfo.has_video  = pcodec->has_video;
         if(IS_AUIDO_NEED_EXT_INFO(pcodec->audio_type))
         {
-            if(pcodec->audio_type!=AFORMAT_WMA && pcodec->audio_type!=AFORMAT_WMAPRO)
+            if (pcodec->audio_type != AFORMAT_WMA && pcodec->audio_type != AFORMAT_WMAPRO && pcodec->audio_type != AFORMAT_WMAVOI)
             {
                  a_ainfo.extradata_size=pcodec->audio_info.extradata_size;
                  if(a_ainfo.extradata_size>0&&a_ainfo.extradata_size<=AUDIO_EXTRA_DATA_SIZE)
@@ -837,6 +882,8 @@ void codec_resume_audio(codec_para_t *pcodec, unsigned int orig)
         a_ainfo.bitrate    =pcodec->audio_info.bitrate;
         a_ainfo.block_align=pcodec->audio_info.block_align;
         a_ainfo.codec_id   =pcodec->audio_info.codec_id;
+        a_ainfo.automute   = pcodec->automute_flag;
+        a_ainfo.has_video  = pcodec->has_video;
 		if (pcodec->switch_audio_flag) {
 			a_ainfo.droppcm_flag = pcodec->switch_audio_flag;
 			if(pcodec->stream_type == STREAM_TYPE_TS || pcodec->stream_type == STREAM_TYPE_PS)
@@ -886,7 +933,7 @@ void codec_resume_audio(codec_para_t *pcodec, unsigned int orig)
 int codec_checkin_pts(codec_para_t *pcodec, unsigned long pts)
 {
     //CODEC_PRINT("[%s:%d]pts=%x(%d)\n",__FUNCTION__,__LINE__,pts,pts/90000);
-    return codec_h_control(pcodec->handle, AMSTREAM_IOC_TSTAMP, pts);
+    return codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET, AMSTREAM_SET_TSTAMP, pts);
 }
 
 /* --------------------------------------------------------------------------*/
@@ -902,9 +949,15 @@ int codec_checkin_pts(codec_para_t *pcodec, unsigned long pts)
 int codec_get_vbuf_state(codec_para_t *p, struct buf_status *buf)
 {
     int r;
-    struct am_io_param am_io;
-    r = codec_h_control(p->handle, AMSTREAM_IOC_VB_STATUS, (unsigned long)&am_io);
-    memcpy(buf, &am_io.status, sizeof(*buf));
+    if(codec_h_is_support_new_cmd()) {
+        struct buf_status status;
+        r = codec_h_ioctl(p->handle, AMSTREAM_IOC_GET_EX, AMSTREAM_GET_EX_VB_STATUS, (unsigned long)&status);
+        memcpy(buf, &status, sizeof(*buf));
+    } else {
+        struct am_io_param am_io;
+        r = codec_h_control(p->handle, AMSTREAM_IOC_VB_STATUS, (unsigned long)&am_io);
+        memcpy(buf, &am_io.status, sizeof(*buf));
+    }
     return system_error_to_codec_error(r);
 }
 /* --------------------------------------------------------------------------*/
@@ -920,9 +973,15 @@ int codec_get_vbuf_state(codec_para_t *p, struct buf_status *buf)
 int codec_get_abuf_state(codec_para_t *p, struct buf_status *buf)
 {
     int r;
-    struct am_io_param am_io;
-    r = codec_h_control(p->handle, AMSTREAM_IOC_AB_STATUS, (unsigned long)&am_io);
-    memcpy(buf, &am_io.status, sizeof(*buf));
+    if(codec_h_is_support_new_cmd()) {
+        struct buf_status status;
+        r = codec_h_ioctl(p->handle, AMSTREAM_IOC_GET_EX, AMSTREAM_GET_EX_AB_STATUS, (unsigned long)&status);
+        memcpy(buf, &status, sizeof(*buf));
+    } else {
+        struct am_io_param am_io;
+        r = codec_h_control(p->handle, AMSTREAM_IOC_AB_STATUS, (unsigned long)&am_io);
+        memcpy(buf, &am_io.status, sizeof(*buf));
+    }
     return system_error_to_codec_error(r);
 }
 
@@ -939,12 +998,18 @@ int codec_get_abuf_state(codec_para_t *p, struct buf_status *buf)
 int codec_get_vdec_state(codec_para_t *p, struct vdec_status *vdec)
 {
     int r;
-    struct am_io_param am_io;
-    r = codec_h_control(p->handle, AMSTREAM_IOC_VDECSTAT, (unsigned long)&am_io);
+    if(codec_h_is_support_new_cmd()) {
+        struct vdec_status vstatus;
+        r = codec_h_ioctl(p->handle, AMSTREAM_IOC_GET_EX, AMSTREAM_GET_EX_VDECSTAT, (unsigned long)&vstatus);
+        memcpy(vdec, &vstatus, sizeof(*vdec));
+    } else {
+        struct am_io_param am_io;
+        r = codec_h_control(p->handle, AMSTREAM_IOC_VDECSTAT, (unsigned long)&am_io);
+        memcpy(vdec, &am_io.vstatus, sizeof(*vdec));
+    }
     if (r < 0) {
         CODEC_PRINT("[codec_get_vdec_state]error[%d]: %s\n", r, codec_error_msg(system_error_to_codec_error(r)));
     }
-    memcpy(vdec, &am_io.vstatus, sizeof(*vdec));
     return system_error_to_codec_error(r);
 }
 
@@ -963,11 +1028,20 @@ int codec_get_adec_state(codec_para_t *p, struct adec_status *adec)
     if(get_audio_decoder()!=AUDIO_ARC_DECODER)
 	return get_decoder_status(p->adec_priv,adec);
     int r;
-    struct am_io_param am_io;
-    r = codec_h_control(p->handle, AMSTREAM_IOC_ADECSTAT, (unsigned long)&am_io);
-    if(r == 0){
-        memcpy(adec, &am_io.astatus, sizeof(*adec));
-    }
+    if(codec_h_is_support_new_cmd()) {
+        struct adec_status astatus;
+        r = codec_h_ioctl(p->handle, AMSTREAM_IOC_GET_EX, AMSTREAM_GET_EX_ADECSTAT, (unsigned long)&astatus);
+        if (r == 0) {
+            memcpy(adec, &astatus, sizeof(*adec));
+        }
+    } else {
+        struct am_io_param am_io;
+        r = codec_h_control(p->handle, AMSTREAM_IOC_ADECSTAT, (unsigned long)&am_io);
+        if(r == 0){
+            memcpy(adec, &am_io.astatus, sizeof(*adec));
+        }
+
+    } 
     return system_error_to_codec_error(r);
 }
 
@@ -1222,7 +1296,7 @@ int codec_get_sub_size(codec_para_t *pcodec)
         return 0;
     }
 
-    r = codec_h_control(pcodec->sub_handle, AMSTREAM_IOC_SUB_LENGTH, (unsigned long)&sub_size);
+    r = codec_h_ioctl(pcodec->sub_handle, AMSTREAM_IOC_GET, AMSTREAM_GET_SUB_LENGTH, (unsigned long)&sub_size);
     if (r < 0) {
         return system_error_to_codec_error(r);
     } else {
@@ -1248,7 +1322,7 @@ int codec_get_sub_size_fd(CODEC_HANDLE sub_fd)
         return 0;
     }
 
-    r = codec_h_control(sub_fd, AMSTREAM_IOC_SUB_LENGTH, (unsigned long)&sub_size);
+    r = codec_h_ioctl(sub_fd, AMSTREAM_IOC_GET, AMSTREAM_GET_SUB_LENGTH, (unsigned long)&sub_size);
     if (r < 0) {
         return system_error_to_codec_error(r);
     } else {
@@ -1497,7 +1571,7 @@ int codec_set_cntl_syncthresh(codec_para_t *pcodec, unsigned int syncthresh)
 /* --------------------------------------------------------------------------*/
 int codec_reset_audio(codec_para_t *pcodec)
 {
-    return codec_h_control(pcodec->handle, AMSTREAM_IOC_AUDIO_RESET, 0);
+    return codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET, AMSTREAM_AUDIO_RESET, 0);
 }
 
 /* --------------------------------------------------------------------------*/
@@ -1511,7 +1585,7 @@ int codec_reset_audio(codec_para_t *pcodec)
 /* --------------------------------------------------------------------------*/
 int codec_reset_subtile(codec_para_t *pcodec)
 {
-    return codec_h_control(pcodec->handle, AMSTREAM_IOC_SUB_RESET, 0);
+    return codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET, AMSTREAM_SUB_RESET, 0);
 }
 
 /* --------------------------------------------------------------------------*/
@@ -1525,7 +1599,7 @@ int codec_reset_subtile(codec_para_t *pcodec)
 /* --------------------------------------------------------------------------*/
 int codec_set_audio_pid(codec_para_t *pcodec)
 {
-    return codec_h_control(pcodec->handle, AMSTREAM_IOC_AID, pcodec->audio_pid);
+    return codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET, AMSTREAM_SET_AID, pcodec->audio_pid);
 }
 
 /* --------------------------------------------------------------------------*/
@@ -1539,7 +1613,7 @@ int codec_set_audio_pid(codec_para_t *pcodec)
 /* --------------------------------------------------------------------------*/
 int codec_set_sub_id(codec_para_t *pcodec)
 {
-    return codec_h_control(pcodec->handle, AMSTREAM_IOC_SID, pcodec->sub_pid);
+    return codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET, AMSTREAM_SET_SID, pcodec->sub_pid);
 }
 
 /* --------------------------------------------------------------------------*/
@@ -1553,7 +1627,7 @@ int codec_set_sub_id(codec_para_t *pcodec)
 /* --------------------------------------------------------------------------*/
 int codec_set_sub_type(codec_para_t *pcodec)
 {
-    return codec_h_control(pcodec->handle, AMSTREAM_IOC_SUB_TYPE, pcodec->sub_type);
+    return codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET, AMSTREAM_SET_SUB_TYPE, pcodec->sub_type);
 }
 
 /* --------------------------------------------------------------------------*/
@@ -1586,7 +1660,7 @@ int codec_audio_reinit(codec_para_t *pcodec)
 /* --------------------------------------------------------------------------*/
 int codec_set_dec_reset(codec_para_t *pcodec)
 {
-    return codec_h_control(pcodec->handle, AMSTREAM_IOC_SET_DEC_RESET, 0);
+    return codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET, AMSTREAM_DEC_RESET, 0);
 }
 
 /* --------------------------------------------------------------------------*/
@@ -1654,8 +1728,8 @@ int codec_get_apts(codec_para_t *pcodec)
         CODEC_PRINT("[%s]ERROR invalid pointer!\n", __FUNCTION__);
         return -1;
     }
-	
-    ret = codec_h_control(pcodec->handle, AMSTREAM_IOC_APTS, (unsigned long)&apts);
+
+    ret = codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_GET, AMSTREAM_GET_APTS, (unsigned long)&apts);
     if (ret < 0) {
         CODEC_PRINT("[%s]ioctl failed %d\n", __FUNCTION__, ret);
         return -1;
@@ -1682,8 +1756,8 @@ int codec_get_vpts(codec_para_t *pcodec)
         CODEC_PRINT("[%s]ERROR invalid pointer!\n", __FUNCTION__);
         return -1;
     }
-	
-    ret = codec_h_control(pcodec->handle, AMSTREAM_IOC_VPTS, (unsigned long)&vpts);
+
+    ret = codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_GET, AMSTREAM_GET_VPTS, (unsigned long)&vpts);
     if (ret < 0) {
         CODEC_PRINT("[%s]ioctl failed %d\n", __FUNCTION__, ret);
         return -1;
@@ -1710,8 +1784,8 @@ int codec_get_pcrscr(codec_para_t *pcodec)
         CODEC_PRINT("[%s]ERROR invalid pointer!\n", __FUNCTION__);
         return -1;
     }
-	
-    ret = codec_h_control(pcodec->handle, AMSTREAM_IOC_PCRSCR, (unsigned long)&pcrscr);
+
+    ret = codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_GET, AMSTREAM_GET_PCRSCR, (unsigned long)&pcrscr);
     if (ret < 0) {
         CODEC_PRINT("[%s]ioctl failed %d\n", __FUNCTION__, ret);
         return -1;
@@ -1719,34 +1793,6 @@ int codec_get_pcrscr(codec_para_t *pcodec)
 
     return pcrscr;
 }
-/* --------------------------------------------------------------------------*/
-/**
-* @brief  codec_get_scrstate  get audio video codec state
-*
-* @param[in]  pcodec  Pointer of codec parameter structure
-*
-* @param[in]  valid sys start time.
-*
-* @return     2 TSYNC_STAT_PCRSCR_SETUP_AUDIO; 1 TSYNC_STAT_PCRSCR_SETUP_VIDEO
-*                 0 TSYNC_STAT_PCRSCR_SETUP_NONE
-*/
-/* --------------------------------------------------------------------------*/
-unsigned int codec_get_scrstate(codec_para_t *pcodec, unsigned long *time)
-{
-    int ret;
-
-    if (pcodec->cntl_handle < 0) {
-        return -1;
-    }
-	
-    ret = ioctl(pcodec->cntl_handle, AMSTREAM_IOC_GET_SCR_STATE, time);
-    if (ret < 0) {
-		CODEC_PRINT("[%s] ioctl failed %d\n", __FUNCTION__, ret);
-        return ret;
-    }	
-	
-    return ret;
-}
 
 /* --------------------------------------------------------------------------*/
 /**
@@ -1767,8 +1813,8 @@ int codec_set_pcrscr(codec_para_t *pcodec, int val)
         CODEC_PRINT("[%s]ERROR invalid pointer!\n", __FUNCTION__);
         return -1;
     }
-	
-    ret = codec_h_control(pcodec->handle, AMSTREAM_IOC_SET_PCRSCR, val);
+
+    ret = codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET, AMSTREAM_SET_PCRSCR, val);
     if (ret < 0) {
         CODEC_PRINT("[%s]ioctl failed %d\n", __FUNCTION__, ret);
         return -1;
@@ -1950,7 +1996,7 @@ int codec_get_sub_num(codec_para_t *pcodec)
     int sub_num = 0;
     int ret;
 
-    ret = codec_h_control(pcodec->handle, AMSTREAM_IOC_SUB_NUM, (unsigned long)&sub_num);
+    ret = codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_GET, AMSTREAM_GET_SUB_NUM, (unsigned long)&sub_num);
     if (ret < 0) {
         return ret;
     }
@@ -1970,17 +2016,17 @@ int codec_get_sub_num(codec_para_t *pcodec)
 int codec_get_sub_info(codec_para_t *pcodec, subtitle_info_t *sub_info)
 {    
     int ret = 0;
-	int i;		
-	if (!sub_info) {
-		CODEC_PRINT("[codec_get_sub_info] error, NULL pointer!\n");
-		ret = CODEC_ERROR_INVAL;
-		return ret;
-	}
-    ret = codec_h_control(pcodec->handle, AMSTREAM_IOC_SUB_INFO, (unsigned long)sub_info);
-	if (ret < 0) {
-		return ret;
-	}	
-    return ret;     
+    int i;
+    if (!sub_info) {
+        CODEC_PRINT("[codec_get_sub_info] error, NULL pointer!\n");
+        ret = CODEC_ERROR_INVAL;
+        return ret;
+    }
+    ret = codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_GET_PTR, AMSTREAM_GET_PTR_SUB_INFO, (unsigned long)sub_info);
+    if (ret < 0) {
+        return ret;
+    }
+    return ret;
 }
 
 /********************************************************************************
@@ -2150,7 +2196,7 @@ int codec_set_audio_resample_type(codec_para_t *pcodec, unsigned long type)
 /* --------------------------------------------------------------------------*/
 int codec_set_video_delay_limited_ms(codec_para_t *pcodec,int delay_ms)
 {
-    return codec_h_control(pcodec->handle, AMSTREAM_IOC_SET_VIDEO_DELAY_LIMIT_MS, delay_ms);
+    return codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET, AMSTREAM_SET_VIDEO_DELAY_LIMIT_MS, delay_ms);
 }
 /* --------------------------------------------------------------------------*/
 /**
@@ -2163,7 +2209,7 @@ int codec_set_video_delay_limited_ms(codec_para_t *pcodec,int delay_ms)
 /* --------------------------------------------------------------------------*/
 int codec_get_video_delay_limited_ms(codec_para_t *pcodec,int *delay_ms)
 {
-    return codec_h_control(pcodec->handle, AMSTREAM_IOC_GET_VIDEO_DELAY_LIMIT_MS, delay_ms);
+    return codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_GET, AMSTREAM_GET_VIDEO_DELAY_LIMIT_MS, delay_ms);
 }
 
 
@@ -2178,7 +2224,7 @@ int codec_get_video_delay_limited_ms(codec_para_t *pcodec,int *delay_ms)
 /* --------------------------------------------------------------------------*/
 int codec_set_audio_delay_limited_ms(codec_para_t *pcodec,int delay_ms)
 {
-    return codec_h_control(pcodec->handle, AMSTREAM_IOC_SET_AUDIO_DELAY_LIMIT_MS, delay_ms);
+    return codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET, AMSTREAM_SET_AUDIO_DELAY_LIMIT_MS, delay_ms);
 }
 
 /* --------------------------------------------------------------------------*/
@@ -2192,7 +2238,7 @@ int codec_set_audio_delay_limited_ms(codec_para_t *pcodec,int delay_ms)
 /* --------------------------------------------------------------------------*/
 int codec_get_audio_delay_limited_ms(codec_para_t *pcodec,int *delay_ms)
 {
-    return codec_h_control(pcodec->handle, AMSTREAM_IOC_GET_AUDIO_DELAY_LIMIT_MS, delay_ms);
+    return codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_GET, AMSTREAM_GET_AUDIO_DELAY_LIMIT_MS, delay_ms);
 }
 
 /* --------------------------------------------------------------------------*/
@@ -2221,7 +2267,7 @@ int codec_get_audio_cur_delay_ms(codec_para_t *pcodec,int *delay_ms)
 /* --------------------------------------------------------------------------*/
 int codec_get_video_cur_delay_ms(codec_para_t *pcodec,int *delay_ms)
 {
-    return codec_h_control(pcodec->handle, AMSTREAM_IOC_GET_VIDEO_CUR_DELAY_MS, delay_ms);
+    return codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_GET, AMSTREAM_GET_VIDEO_CUR_DELAY_MS, delay_ms);
 }
 
 /* --------------------------------------------------------------------------*/
@@ -2235,7 +2281,7 @@ int codec_get_video_cur_delay_ms(codec_para_t *pcodec,int *delay_ms)
 /* --------------------------------------------------------------------------*/
 int codec_get_video_cur_bitrate(codec_para_t *pcodec,int *bitrate)
 {
-    return codec_h_control(pcodec->handle, AMSTREAM_IOC_GET_VIDEO_AVG_BITRATE_BPS, bitrate);
+    return codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_GET, AMSTREAM_GET_VIDEO_AVG_BITRATE_BPS, bitrate);
 }
 
 
@@ -2250,7 +2296,7 @@ int codec_get_video_cur_bitrate(codec_para_t *pcodec,int *bitrate)
 /* --------------------------------------------------------------------------*/
 int codec_get_audio_cur_bitrate(codec_para_t *pcodec,int *bitrate)
 {
-    return codec_h_control(pcodec->handle, AMSTREAM_IOC_GET_AUDIO_AVG_BITRATE_BPS, bitrate);
+    return codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_GET, AMSTREAM_GET_AUDIO_AVG_BITRATE_BPS, bitrate);
 }
 
 /* --------------------------------------------------------------------------*/
@@ -2267,9 +2313,9 @@ int codec_set_vsync_upint(codec_para_t *pcodec, unsigned int mode)
 {
     return codec_h_control(pcodec->cntl_handle, AMSTREAM_IOC_SET_VSYNC_UPINT, (unsigned long)mode);
 }
-int codec_set_drmmode(codec_para_t *pcodec)
+int codec_set_drmmode(codec_para_t *pcodec, unsigned int mode)
 {
-    return codec_h_control(pcodec->handle, AMSTREAM_IOC_SET_DRMMODE, 0);
+    return codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_SET, AMSTREAM_SET_DRMMODE, mode);
 }
 
 /**
@@ -2278,12 +2324,12 @@ int codec_set_drmmode(codec_para_t *pcodec)
  */
 int codec_get_last_checkout_apts(codec_para_t* pcodec, unsigned long *apts)
 {
-  return codec_h_control(pcodec->handle, AMSTREAM_IOC_GET_LAST_CHECKOUT_APTS, apts);
+    return codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_GET, AMSTREAM_GET_LAST_CHECKOUT_APTS, apts);
 }
 
 int codec_get_last_checkin_apts(codec_para_t* pcodec, unsigned long* apts)
 {
-  return codec_h_control(pcodec->handle, AMSTREAM_IOC_GET_LAST_CHECKIN_APTS, apts);
+    return codec_h_ioctl(pcodec->handle, AMSTREAM_IOC_GET, AMSTREAM_GET_LAST_CHECKIN_APTS, apts);
 }
 
 /**
diff --git a/amcodec/codec/codec_h_ctrl.c b/amcodec/codec/codec_h_ctrl.c
index f62bd0d..b7dc67b 100755
--- a/amcodec/codec/codec_h_ctrl.c
+++ b/amcodec/codec/codec_h_ctrl.c
@@ -21,7 +21,7 @@
 #include <codec_error.h>
 #include <codec.h>
 #include "codec_h_ctrl.h"
-
+#include "amports/amstream.h"
 //------------------------------
 #include <sys/times.h>
 #define msleep(n)	usleep(n*1000)
@@ -127,6 +127,384 @@ int codec_h_control(CODEC_HANDLE h, int cmd, unsigned long paramter)
     return 0;
 }
 
+static struct codec_amd_table {
+	unsigned int cmd;
+	unsigned int parm_cmd;
+} cmd_tables[] = {
+    { AMSTREAM_IOC_VB_START, AMSTREAM_SET_VB_START },
+    { AMSTREAM_IOC_VB_SIZE, AMSTREAM_SET_VB_SIZE },
+    { AMSTREAM_IOC_AB_START, AMSTREAM_SET_AB_START },
+    { AMSTREAM_IOC_AB_SIZE, AMSTREAM_SET_AB_SIZE },
+    { AMSTREAM_IOC_VFORMAT, AMSTREAM_SET_VFORMAT },
+    { AMSTREAM_IOC_AFORMAT, AMSTREAM_SET_AFORMAT },
+    { AMSTREAM_IOC_VID, AMSTREAM_SET_VID },
+    { AMSTREAM_IOC_AID, AMSTREAM_SET_AID },
+    { AMSTREAM_IOC_VB_STATUS, AMSTREAM_GET_EX_VB_STATUS },
+    { AMSTREAM_IOC_AB_STATUS, AMSTREAM_GET_EX_AB_STATUS },
+    { AMSTREAM_IOC_ACHANNEL, AMSTREAM_SET_ACHANNEL },
+    { AMSTREAM_IOC_SAMPLERATE, AMSTREAM_SET_SAMPLERATE },
+    { AMSTREAM_IOC_DATAWIDTH, AMSTREAM_SET_DATAWIDTH },
+    { AMSTREAM_IOC_TSTAMP, AMSTREAM_SET_TSTAMP },
+    { AMSTREAM_IOC_VDECSTAT, AMSTREAM_GET_EX_VDECSTAT },
+    { AMSTREAM_IOC_ADECSTAT, AMSTREAM_GET_EX_ADECSTAT },
+    { AMSTREAM_IOC_PORT_INIT, AMSTREAM_PORT_INIT },
+    { AMSTREAM_IOC_TRICKMODE, AMSTREAM_SET_TRICKMODE },
+    { AMSTREAM_IOC_AUDIO_INFO, AMSTREAM_SET_PTR_AUDIO_INFO },
+    { AMSTREAM_IOC_AUDIO_RESET, AMSTREAM_AUDIO_RESET },
+    { AMSTREAM_IOC_SID, AMSTREAM_SET_SID },
+    { AMSTREAM_IOC_SUB_RESET, AMSTREAM_SUB_RESET },
+    { AMSTREAM_IOC_SUB_LENGTH, AMSTREAM_GET_SUB_LENGTH },
+    { AMSTREAM_IOC_SET_DEC_RESET, AMSTREAM_DEC_RESET },
+    { AMSTREAM_IOC_TS_SKIPBYTE, AMSTREAM_SET_TS_SKIPBYTE },
+    { AMSTREAM_IOC_SUB_TYPE, AMSTREAM_SET_SUB_TYPE },
+    { AMSTREAM_IOC_APTS, AMSTREAM_GET_APTS },
+    { AMSTREAM_IOC_VPTS, AMSTREAM_GET_VPTS },
+    { AMSTREAM_IOC_PCRSCR, AMSTREAM_GET_PCRSCR },
+    { AMSTREAM_IOC_SET_PCRSCR, AMSTREAM_SET_PCRSCR },
+    { AMSTREAM_IOC_SUB_NUM, AMSTREAM_GET_SUB_NUM },
+    { AMSTREAM_IOC_SUB_INFO, AMSTREAM_GET_PTR_SUB_INFO },
+    { AMSTREAM_IOC_UD_LENGTH, AMSTREAM_GET_UD_LENGTH },
+    { AMSTREAM_IOC_UD_POC, AMSTREAM_GET_EX_UD_POC },
+    { AMSTREAM_IOC_APTS_LOOKUP, AMSTREAM_GET_APTS_LOOKUP },
+    { GET_FIRST_APTS_FLAG, AMSTREAM_GET_FIRST_APTS_FLAG },
+    { AMSTREAM_IOC_SET_DEMUX, AMSTREAM_SET_DEMUX },
+    { AMSTREAM_IOC_SET_DRMMODE, AMSTREAM_SET_DRMMODE },
+    { AMSTREAM_IOC_TSTAMP_uS64, AMSTREAM_SET_TSTAMP_US64 },
+    { AMSTREAM_IOC_SET_VIDEO_DELAY_LIMIT_MS, AMSTREAM_SET_VIDEO_DELAY_LIMIT_MS },
+    { AMSTREAM_IOC_GET_VIDEO_DELAY_LIMIT_MS, AMSTREAM_GET_VIDEO_DELAY_LIMIT_MS },
+    { AMSTREAM_IOC_SET_AUDIO_DELAY_LIMIT_MS, AMSTREAM_SET_AUDIO_DELAY_LIMIT_MS },
+    { AMSTREAM_IOC_GET_AUDIO_DELAY_LIMIT_MS, AMSTREAM_GET_AUDIO_DELAY_LIMIT_MS },
+    { AMSTREAM_IOC_GET_AUDIO_CUR_DELAY_MS, AMSTREAM_GET_AUDIO_CUR_DELAY_MS },
+    { AMSTREAM_IOC_GET_VIDEO_CUR_DELAY_MS, AMSTREAM_GET_VIDEO_CUR_DELAY_MS },
+    { AMSTREAM_IOC_GET_AUDIO_AVG_BITRATE_BPS, AMSTREAM_GET_AUDIO_AVG_BITRATE_BPS },
+    { AMSTREAM_IOC_GET_VIDEO_AVG_BITRATE_BPS, AMSTREAM_GET_VIDEO_AVG_BITRATE_BPS },
+    { AMSTREAM_IOC_SET_APTS, AMSTREAM_SET_APTS },
+    { AMSTREAM_IOC_GET_LAST_CHECKIN_APTS, AMSTREAM_GET_LAST_CHECKIN_APTS },
+    { AMSTREAM_IOC_GET_LAST_CHECKIN_VPTS, AMSTREAM_GET_LAST_CHECKIN_VPTS },
+    { AMSTREAM_IOC_GET_LAST_CHECKOUT_APTS, AMSTREAM_GET_LAST_CHECKOUT_APTS },
+    { AMSTREAM_IOC_GET_LAST_CHECKOUT_VPTS, AMSTREAM_GET_LAST_CHECKOUT_VPTS },
+    /*video cmd*/
+    //{ AMSTREAM_IOC_TRICK_STAT, AMSTREAM_GET_TRICK_STAT },
+    //{ AMSTREAM_IOC_VPAUSE, AMSTREAM_SET_VPAUSE },
+    //{ AMSTREAM_IOC_AVTHRESH, AMSTREAM_SET_AVTHRESH },
+    //{ AMSTREAM_IOC_SYNCTHRESH, AMSTREAM_SET_SYNCTHRESH },
+    //{ AMSTREAM_IOC_CLEAR_VIDEO, AMSTREAM_SET_CLEAR_VIDEO },
+    //{ AMSTREAM_IOC_SYNCENABLE, AMSTREAM_SET_SYNCENABLE },
+    //{ AMSTREAM_IOC_GET_SYNC_ADISCON, AMSTREAM_GET_SYNC_ADISCON },
+    //{ AMSTREAM_IOC_SET_SYNC_ADISCON, AMSTREAM_SET_SYNC_ADISCON },
+    //{ AMSTREAM_IOC_GET_SYNC_VDISCON, AMSTREAM_GET_SYNC_VDISCON },
+    //{ AMSTREAM_IOC_SET_SYNC_VDISCON, AMSTREAM_SET_SYNC_VDISCON },
+    //{ AMSTREAM_IOC_GET_VIDEO_DISABLE, AMSTREAM_GET_VIDEO_DISABLE },
+    //{ AMSTREAM_IOC_SET_VIDEO_DISABLE, AMSTREAM_SET_VIDEO_DISABLE },
+    //{ AMSTREAM_IOC_SYNCENABLE, AMSTREAM_SET_SYNCENABLE },
+    //{ AMSTREAM_IOC_GET_SYNC_ADISCON, AMSTREAM_GET_SYNC_ADISCON },
+    //{ AMSTREAM_IOC_SET_SYNC_ADISCON, AMSTREAM_SET_SYNC_ADISCON },
+    //{ AMSTREAM_IOC_GET_SYNC_VDISCON, AMSTREAM_GET_SYNC_VDISCON },
+    //{ AMSTREAM_IOC_SET_SYNC_VDISCON, AMSTREAM_SET_SYNC_VDISCON },
+    //{ AMSTREAM_IOC_GET_VIDEO_DISABLE, AMSTREAM_GET_VIDEO_DISABLE },
+    //{ AMSTREAM_IOC_SET_VIDEO_DISABLE, AMSTREAM_SET_VIDEO_DISABLE },
+    //{ AMSTREAM_IOC_GET_VIDEO_AXIS, AMSTREAM_GET_EX_VIDEO_AXIS },
+    //{ AMSTREAM_IOC_SET_VIDEO_AXIS, AMSTREAM_SET_EX_VIDEO_AXIS },
+    //{ AMSTREAM_IOC_GET_VIDEO_CROP, AMSTREAM_GET_EX_VIDEO_CROP },
+    //{ AMSTREAM_IOC_SET_VIDEO_CROP, AMSTREAM_SET_EX_VIDEO_CROP },
+    //{ AMSTREAM_IOC_PCRID, AMSTREAM_SET_PCRID },
+    //{ AMSTREAM_IOC_SET_3D_TYPE, AMSTREAM_SET_3D_TYPE },
+    //{ AMSTREAM_IOC_GET_3D_TYPE, AMSTREAM_GET_3D_TYPE },
+    //{ AMSTREAM_IOC_GET_BLACKOUT_POLICY, AMSTREAM_GET_BLACKOUT_POLICY },
+    //{ AMSTREAM_IOC_SET_BLACKOUT_POLICY, AMSTREAM_SET_BLACKOUT_POLICY },
+    //{ AMSTREAM_IOC_GET_SCREEN_MODE, AMSTREAM_GET_SCREEN_MODE },
+    //{ AMSTREAM_IOC_SET_SCREEN_MODE, AMSTREAM_SET_SCREEN_MODE },
+    //{ AMSTREAM_IOC_GET_VIDEO_DISCONTINUE_REPORT, AMSTREAM_GET_VIDEO_DISCONTINUE_REPORT },
+    //{ AMSTREAM_IOC_SET_VIDEO_DISCONTINUE_REPORT, AMSTREAM_SET_VIDEO_DISCONTINUE_REPORT },
+    //{ AMSTREAM_IOC_VF_STATUS, AMSTREAM_GET_VF_STATUS },
+    //{ AMSTREAM_IOC_CLEAR_VBUF, AMSTREAM_CLEAR_VBUF },
+    //{ AMSTREAM_IOC_GET_SYNC_ADISCON_DIFF, AMSTREAM_GET_SYNC_ADISCON_DIFF },
+    //{ AMSTREAM_IOC_GET_SYNC_VDISCON_DIFF, AMSTREAM_GET_SYNC_VDISCON_DIFF },
+    //{ AMSTREAM_IOC_SET_SYNC_ADISCON_DIFF, AMSTREAM_SET_SYNC_ADISCON_DIFF },
+    //{ AMSTREAM_IOC_SET_SYNC_VDISCON_DIFF, AMSTREAM_SET_SYNC_VDISCON_DIFF },
+    //{ AMSTREAM_IOC_GET_FREERUN_MODE, AMSTREAM_GET_FREERUN_MODE },
+    //{ AMSTREAM_IOC_SET_FREERUN_MODE, AMSTREAM_SET_FREERUN_MODE },
+    //{ AMSTREAM_IOC_SET_VSYNC_UPINT, AMSTREAM_SET_VSYNC_UPINT },
+    //{ AMSTREAM_IOC_GET_VSYNC_SLOW_FACTOR, AMSTREAM_GET_VSYNC_SLOW_FACTOR },
+    //{ AMSTREAM_IOC_SET_VSYNC_SLOW_FACTOR, AMSTREAM_SET_VSYNC_SLOW_FACTOR },
+    //{ AMSTREAM_IOC_SET_OMX_VPTS, AMSTREAM_SET_OMX_VPTS },
+    //{ AMSTREAM_IOC_GET_OMX_VPTS, AMSTREAM_GET_OMX_VPTS },
+    //{ AMSTREAM_IOC_GET_TRICK_VPTS, AMSTREAM_GET_TRICK_VPTS },
+    //{ AMSTREAM_IOC_DISABLE_SLOW_SYNC, AMSTREAM_GET_DISABLE_SLOW_SYNC },
+    /* subtitle cmd */
+    //{ AMSTREAM_IOC_GET_SUBTITLE_INFO, AMSTREAM_GET_SUBTITLE_INFO },
+    //{ AMSTREAM_IOC_SET_SUBTITLE_INFO, AMSTREAM_SET_SUBTITLE_INFO },
+    { 0, 0 },
+};
+int get_old_cmd(int cmd)
+{
+    struct codec_amd_table *p;
+    for (p = cmd_tables; p->cmd; p++) {
+        if (p->parm_cmd == cmd) {
+            return p->cmd;
+        }
+    }
+    return -1;
+}
+
+static int codec_h_ioctl_set(CODEC_HANDLE h, int subcmd, unsigned long paramter)
+{
+    int r;
+    int cmd_new = AMSTREAM_IOC_SET;
+    unsigned long parm_new;
+    switch (subcmd) {
+    case AMSTREAM_SET_VB_SIZE:
+    case AMSTREAM_SET_AB_SIZE:
+    case AMSTREAM_SET_VID:
+    case AMSTREAM_SET_ACHANNEL:
+    case AMSTREAM_SET_SAMPLERATE:
+    case AMSTREAM_SET_TSTAMP:
+    case AMSTREAM_SET_AID:
+    case AMSTREAM_SET_TRICKMODE:
+    case AMSTREAM_SET_SID:
+    case AMSTREAM_SET_TS_SKIPBYTE:
+    case AMSTREAM_SET_PCRSCR:
+    case AMSTREAM_SET_SUB_TYPE:
+    case AMSTREAM_SET_DEMUX:
+    case AMSTREAM_SET_VIDEO_DELAY_LIMIT_MS:
+    case AMSTREAM_SET_AUDIO_DELAY_LIMIT_MS:
+    case AMSTREAM_SET_DRMMODE: {
+        struct am_ioctl_parm parm;
+        memset(&parm, 0, sizeof(parm));
+        parm.cmd = subcmd;
+        parm.data_32 = paramter;
+        parm_new = (unsigned long)&parm;
+        r = ioctl(h, cmd_new, parm_new);
+    }
+    break;
+    case AMSTREAM_SET_VFORMAT: {
+        struct am_ioctl_parm parm;
+        memset(&parm, 0, sizeof(parm));
+        parm.cmd = subcmd;
+        parm.data_vformat = paramter;
+        parm_new = (unsigned long)&parm;
+        r = ioctl(h, cmd_new, parm_new);
+    }
+    break;
+    case AMSTREAM_SET_AFORMAT: {
+        struct am_ioctl_parm parm;
+        memset(&parm, 0, sizeof(parm));
+        parm.cmd = subcmd;
+        parm.data_aformat = paramter;
+        parm_new = (unsigned long)&parm;
+        r = ioctl(h, cmd_new, parm_new);
+    }
+    break;
+    case AMSTREAM_PORT_INIT:
+    case AMSTREAM_AUDIO_RESET:
+    case AMSTREAM_SUB_RESET:
+    case AMSTREAM_DEC_RESET: {
+        struct am_ioctl_parm parm;
+        memset(&parm, 0, sizeof(parm));
+        parm.cmd = subcmd;
+        parm_new = (unsigned long)&parm;
+        r = ioctl(h, cmd_new, parm_new);
+    }
+    break;
+    default: {
+        struct am_ioctl_parm parm;
+        memset(&parm, 0, sizeof(parm));
+        parm.cmd = subcmd;
+        parm.data_32 = paramter;
+        parm_new = (unsigned long)&parm;
+        r = ioctl(h, cmd_new, parm_new);
+    }
+    break;
+    }
+
+    if (r < 0) {
+        CODEC_PRINT("codec_h_ioctl_set failed,handle=%d,cmd=%x,paramter=%x, t=%x errno=%d\n", h, subcmd, paramter, r, errno);
+        return r;
+    }
+    return 0;
+}
+static int codec_h_ioctl_set_ex(CODEC_HANDLE h, int subcmd, unsigned long paramter)
+{
+    return 0;
+}
+static int codec_h_ioctl_set_ptr(CODEC_HANDLE h, int subcmd, unsigned long paramter)
+{
+    int r;
+    int cmd_new = AMSTREAM_IOC_SET_PTR;
+    unsigned long parm_new;
+    switch (subcmd) {
+    case AMSTREAM_SET_PTR_AUDIO_INFO: {
+        struct am_ioctl_parm_ptr parm;
+        memset(&parm, 0, sizeof(parm));
+        parm.cmd = subcmd;
+        parm.pdata_audio_info = paramter;
+        parm_new = (unsigned long)&parm;
+        r = ioctl(h, cmd_new, parm_new);
+    }
+    break;
+    default:
+        r = -1;
+        break;
+    }
+    if (r < 0) {
+        CODEC_PRINT("codec_h_ioctl_set_ptr failed,handle=%d,subcmd=%x,paramter=%x, t=%x errno=%d\n", h, subcmd, paramter, r, errno);
+        return r;
+    }
+    return 0;
+}
+static int codec_h_ioctl_get(CODEC_HANDLE h, int subcmd, unsigned long paramter)
+{
+    int r;
+    struct am_ioctl_parm parm;
+    unsigned long parm_new;
+    memset(&parm, 0, sizeof(parm));
+    parm.cmd = subcmd;
+    parm.data_32 = *(unsigned int *)paramter;
+    parm_new = (unsigned long)&parm;
+    r = ioctl(h, AMSTREAM_IOC_GET, parm_new);
+    if (r < 0) {
+        CODEC_PRINT("codec_h_ioctl_get failed,handle=%d,subcmd=%x,paramter=%x, t=%x errno=%d\n", h, subcmd, paramter, r, errno);
+        return r;
+    }
+    if (paramter != 0) {
+        *(unsigned int *)paramter = parm.data_32;
+    }
+    return 0;
+}
+static int codec_h_ioctl_get_ex(CODEC_HANDLE h, int subcmd, unsigned long paramter)
+{
+    int r;
+    int cmd_new = AMSTREAM_IOC_GET_EX;
+    unsigned long parm_new;
+    switch (subcmd) {
+    case AMSTREAM_GET_EX_VB_STATUS:
+    case AMSTREAM_GET_EX_AB_STATUS: {
+        struct am_ioctl_parm_ex parm;
+        memset(&parm, 0, sizeof(parm));
+        parm.cmd = subcmd;
+        parm_new = (unsigned long)&parm;
+        r = ioctl(h, cmd_new, parm_new);
+        if (r >= 0 && paramter != 0) {
+            memcpy((void *)paramter, &parm.status, sizeof(struct buf_status));
+        }
+    }
+    break;
+    case AMSTREAM_GET_EX_VDECSTAT: {
+        struct am_ioctl_parm_ex parm;
+        memset(&parm, 0, sizeof(parm));
+        parm.cmd = subcmd;
+        parm_new = (unsigned long)&parm;
+        r = ioctl(h, cmd_new, parm_new);
+        if (r >= 0 && paramter != 0) {
+            memcpy((void *)paramter, &parm.vstatus, sizeof(struct vdec_status));
+        }
+    }
+    break;
+    case AMSTREAM_GET_EX_ADECSTAT: {
+        struct am_ioctl_parm_ex parm;
+        memset(&parm, 0, sizeof(parm));
+        parm.cmd = subcmd;
+        parm_new = (unsigned long)&parm;
+        r = ioctl(h, cmd_new, parm_new);
+        if (r >= 0 && paramter != 0) {
+            memcpy((void *)paramter, &parm.astatus, sizeof(struct adec_status));
+        }
+    }
+    break;
+    default:
+        r = -1;
+        break;
+    }
+    if (r < 0) {
+        CODEC_PRINT("codec_h_ioctl_get_ex failed,handle=%d,subcmd=%x,paramter=%x, t=%x errno=%d\n", h, subcmd, paramter, r, errno);
+        return r;
+    }
+    return 0;
+
+}
+static int codec_h_ioctl_get_ptr(CODEC_HANDLE h, int subcmd, unsigned long paramter)
+{
+    int r;
+    int cmd_new = AMSTREAM_IOC_GET_PTR;
+    unsigned long parm_new;
+    switch (subcmd) {
+    case AMSTREAM_IOC_SUB_INFO: {
+        struct am_ioctl_parm_ptr parm;
+        memset(&parm, 0, sizeof(parm));
+        parm.cmd = subcmd;
+        parm.pdata_sub_info = paramter;
+        parm_new = (unsigned long)&parm;
+        r = ioctl(h, cmd_new, parm_new);
+    }
+    break;
+    default:
+        r = -1;
+        break;
+    }
+    if (r < 0) {
+        CODEC_PRINT("codec_h_ioctl_get_ptr failed,handle=%d,subcmd=%x,paramter=%x, t=%x errno=%d\n", h, subcmd, paramter, r, errno);
+        return r;
+    }
+    return 0;
+}
+/* --------------------------------------------------------------------------*/
+/**
+* @brief  codec_h_control  IOCTL commands for codec devices
+*
+* @param[in]  h         Codec device handler
+* @param[in]  cmd       IOCTL commands
+* @param[in]  paramter  IOCTL commands parameter
+*
+* @return     0 for success, non-0 for fail
+*/
+/* --------------------------------------------------------------------------*/
+int codec_h_ioctl(CODEC_HANDLE h, int cmd, int subcmd, unsigned long paramter)
+{
+    int r;
+    int cmd_new;
+    unsigned long parm_new;
+    if (h < 0) {
+        return -1;
+    }
+    //printf("[%s]l: %d --->cmd:%x, subcmd:%x\n", __func__, __LINE__, cmd, subcmd);
+    if (!codec_h_is_support_new_cmd()) {
+        int old_cmd = get_old_cmd(subcmd);
+        if (old_cmd == -1) {
+            return -1;
+        }
+        return codec_h_control(h, old_cmd, paramter);
+    }
+    switch (cmd) {
+    case AMSTREAM_IOC_SET:
+        r = codec_h_ioctl_set(h, subcmd, paramter);
+        break;
+    case AMSTREAM_IOC_SET_EX:
+        r = codec_h_ioctl_set_ex(h, subcmd, paramter);
+        break;
+    case AMSTREAM_IOC_SET_PTR:
+        r = codec_h_ioctl_set_ptr(h, subcmd, paramter);
+        break;
+    case AMSTREAM_IOC_GET:
+        r = codec_h_ioctl_get(h, subcmd, paramter);
+        break;
+    case AMSTREAM_IOC_GET_EX:
+        r = codec_h_ioctl_get_ex(h, subcmd, paramter);
+        break;
+    case AMSTREAM_IOC_GET_PTR:
+        r = codec_h_ioctl_get_ptr(h, subcmd, paramter);
+        break;
+    default:
+        r = ioctl(h, cmd, paramter);
+        break;
+    }
+
+    if (r < 0) {
+        CODEC_PRINT("codec_h_ioctl failed,handle=%d,cmd=%x,subcmd=%x, paramter=%x, t=%x errno=%d\n", h, cmd, subcmd, paramter, r, errno);
+        return r;
+    }
+    return 0;
+}
+
 /* --------------------------------------------------------------------------*/
 /**
 * @brief  codec_h_read  Read data from codec devices
@@ -169,5 +547,33 @@ int codec_h_write(CODEC_HANDLE handle, void *buffer, int size)
     return r;
 }
 
+static int support_new_cmd = 0;
+/* --------------------------------------------------------------------------*/
+/**
+* @brief  codec_h_set_support_new_cmd  set support new cmd
+*
+* @param[in]   handle  Codec device handler
+*
+* @return      write length or fail if < 0
+*/
+/* --------------------------------------------------------------------------*/
+void codec_h_set_support_new_cmd(int value)
+{
+    support_new_cmd = value;
+}
+
+/* --------------------------------------------------------------------------*/
+/**
+* @brief  codec_h_set_support_new_cmd  set support new cmd
+*
+* @param[in]   handle  Codec device handler
+*
+* @return      write length or fail if < 0
+*/
+/* --------------------------------------------------------------------------*/
+int codec_h_is_support_new_cmd()
+{
+    return support_new_cmd;
+}
 
 
diff --git a/amcodec/codec/codec_h_ctrl.h b/amcodec/codec/codec_h_ctrl.h
index 55d905d..b566170 100755
--- a/amcodec/codec/codec_h_ctrl.h
+++ b/amcodec/codec/codec_h_ctrl.h
@@ -48,7 +48,8 @@ int codec_h_close(CODEC_HANDLE h);
 int codec_h_write(CODEC_HANDLE , void *, int);
 int codec_h_read(CODEC_HANDLE, void *, int);
 int codec_h_control(CODEC_HANDLE h, int cmd, unsigned long paramter);
-
+void codec_h_set_support_new_cmd(int value);
+int codec_h_is_support_new_cmd();
 
 
 #endif
diff --git a/amcodec/include/amports/aformat.h b/amcodec/include/amports/aformat.h
index d47fde8..c8e9fcd 100755
--- a/amcodec/include/amports/aformat.h
+++ b/amcodec/include/amports/aformat.h
@@ -59,6 +59,12 @@ typedef enum {
     AFORMAT_APE   = 20,
     AFORMAT_EAC3   = 21,   
     AFORMAT_PCM_WIFIDISPLAY = 22,
+    AFORMAT_DRA    = 23,
+    AFORMAT_SIPR   = 24,
+    AFORMAT_TRUEHD = 25,
+    AFORMAT_MPEG1  = 26, //AFORMAT_MPEG-->mp3,AFORMAT_MPEG1-->mp1,AFROMAT_MPEG2-->mp2
+    AFORMAT_MPEG2  = 27,
+    AFORMAT_WMAVOI = 28,
     AFORMAT_UNSUPPORT ,
     AFORMAT_MAX    
 
@@ -68,21 +74,23 @@ typedef enum {
 #define IS_AFMT_VALID(afmt)	((afmt > AFORMAT_UNKNOWN) && (afmt < AFORMAT_MAX))
     
 #define IS_AUIDO_NEED_EXT_INFO(afmt) ((afmt == AFORMAT_ADPCM) \
-								 ||(afmt == AFORMAT_WMA) \
-								 ||(afmt == AFORMAT_WMAPRO) \
-								 ||(afmt == AFORMAT_PCM_S16BE) \
-								 ||(afmt == AFORMAT_PCM_S16LE) \
-								 ||(afmt == AFORMAT_PCM_U8) \
-								 ||(afmt == AFORMAT_PCM_BLURAY) \
-								 ||(afmt == AFORMAT_AMR)\
-								 ||(afmt == AFORMAT_ALAC)\
-								 ||(afmt == AFORMAT_AC3) \
-								 ||(afmt == AFORMAT_EAC3) \								 
-								 ||(afmt == AFORMAT_APE) \
-								 ||(afmt == AFORMAT_FLAC)\
-								 ||(afmt == AFORMAT_PCM_WIFIDISPLAY) \
-								 ||(afmt == AFORMAT_COOK) \
-								 ||(afmt == AFORMAT_RAAC))
+                                 ||(afmt == AFORMAT_WMA) \
+                                 ||(afmt == AFORMAT_WMAPRO) \
+                                 ||(afmt == AFORMAT_PCM_S16BE) \
+                                 ||(afmt == AFORMAT_PCM_S16LE) \
+                                 ||(afmt == AFORMAT_PCM_U8) \
+                                 ||(afmt == AFORMAT_PCM_BLURAY) \
+                                 ||(afmt == AFORMAT_AMR)\
+                                 ||(afmt == AFORMAT_ALAC)\
+                                 ||(afmt == AFORMAT_AC3) \
+                                 ||(afmt == AFORMAT_EAC3) \
+                                 ||(afmt == AFORMAT_APE) \
+                                 ||(afmt == AFORMAT_FLAC)\
+                                 ||(afmt == AFORMAT_PCM_WIFIDISPLAY) \
+                                 ||(afmt == AFORMAT_COOK) \
+                                 ||(afmt == AFORMAT_RAAC)) \
+                                 ||(afmt == AFORMAT_TRUEHD) \
+                                 ||(afmt == AFORMAT_WMAVOI)
 
 
 #define IS_AUDIO_NOT_SUPPORT_EXCEED_2CH(afmt) ((afmt == AFORMAT_RAAC) \
@@ -95,7 +103,10 @@ typedef enum {
 
 #define IS_AUIDO_NEED_PREFEED_HEADER(afmt) ((afmt == AFORMAT_VORBIS) )
 #define IS_AUDIO_NOT_SUPPORTED_BY_AUDIODSP(afmt,codec)  \
-							((afmt == AFORMAT_AAC_LATM || afmt == AFORMAT_AAC) \
-							 &&codec->profile == 0/* FF_PROFILE_AAC_MAIN*/)
+                            ((afmt == AFORMAT_AAC_LATM || afmt == AFORMAT_AAC) \
+                             &&codec->profile == 0/* FF_PROFILE_AAC_MAIN*/)
+
+#define IS_SUB_NEED_PREFEED_HEADER(sfmt) ((sfmt == CODEC_ID_DVD_SUBTITLE) )
+
 #endif /* AFORMAT_H */
 
diff --git a/amcodec/include/amports/amstream.h b/amcodec/include/amports/amstream.h
index 0d964f1..aa1f32d 100755
--- a/amcodec/include/amports/amstream.h
+++ b/amcodec/include/amports/amstream.h
@@ -34,6 +34,8 @@
 #ifndef AMSTREAM_H
 #define AMSTREAM_H
 
+#include "amports/vformat.h"
+#include "amports/aformat.h"
 #define PORT_FLAG_IN_USE    0x0001
 #define PORT_FLAG_VFORMAT   0x0002
 #define PORT_FLAG_AFORMAT   0x0004
@@ -51,84 +53,126 @@
 #define PORT_TYPE_RM        0x20
 
 #define AMSTREAM_IOC_MAGIC  'S'
+#define AMSTREAM_IOC_VB_START   _IOW((AMSTREAM_IOC_MAGIC), 0x00, int)
+#define AMSTREAM_IOC_VB_SIZE    _IOW((AMSTREAM_IOC_MAGIC), 0x01, int)
+#define AMSTREAM_IOC_AB_START   _IOW((AMSTREAM_IOC_MAGIC), 0x02, int)
+#define AMSTREAM_IOC_AB_SIZE    _IOW((AMSTREAM_IOC_MAGIC), 0x03, int)
+#define AMSTREAM_IOC_VFORMAT    _IOW((AMSTREAM_IOC_MAGIC), 0x04, int)
+#define AMSTREAM_IOC_AFORMAT    _IOW((AMSTREAM_IOC_MAGIC), 0x05, int)
+#define AMSTREAM_IOC_VID        _IOW((AMSTREAM_IOC_MAGIC), 0x06, int)
+#define AMSTREAM_IOC_AID        _IOW((AMSTREAM_IOC_MAGIC), 0x07, int)
+#define AMSTREAM_IOC_VB_STATUS  _IOR((AMSTREAM_IOC_MAGIC), 0x08, int)
+#define AMSTREAM_IOC_AB_STATUS  _IOR((AMSTREAM_IOC_MAGIC), 0x09, int)
+#define AMSTREAM_IOC_SYSINFO    _IOW((AMSTREAM_IOC_MAGIC), 0x0a, int)
+#define AMSTREAM_IOC_ACHANNEL   _IOW((AMSTREAM_IOC_MAGIC), 0x0b, int)
+#define AMSTREAM_IOC_SAMPLERATE _IOW((AMSTREAM_IOC_MAGIC), 0x0c, int)
+#define AMSTREAM_IOC_DATAWIDTH  _IOW((AMSTREAM_IOC_MAGIC), 0x0d, int)
+#define AMSTREAM_IOC_TSTAMP     _IOW((AMSTREAM_IOC_MAGIC), 0x0e, int)
+#define AMSTREAM_IOC_VDECSTAT   _IOR((AMSTREAM_IOC_MAGIC), 0x0f, int)
+#define AMSTREAM_IOC_ADECSTAT   _IOR((AMSTREAM_IOC_MAGIC), 0x10, int)
 
-#define AMSTREAM_IOC_VB_START   _IOW(AMSTREAM_IOC_MAGIC, 0x00, int)
-#define AMSTREAM_IOC_VB_SIZE    _IOW(AMSTREAM_IOC_MAGIC, 0x01, int)
-#define AMSTREAM_IOC_AB_START   _IOW(AMSTREAM_IOC_MAGIC, 0x02, int)
-#define AMSTREAM_IOC_AB_SIZE    _IOW(AMSTREAM_IOC_MAGIC, 0x03, int)
-#define AMSTREAM_IOC_VFORMAT    _IOW(AMSTREAM_IOC_MAGIC, 0x04, int)
-#define AMSTREAM_IOC_AFORMAT    _IOW(AMSTREAM_IOC_MAGIC, 0x05, int)
-#define AMSTREAM_IOC_VID        _IOW(AMSTREAM_IOC_MAGIC, 0x06, int)
-#define AMSTREAM_IOC_AID        _IOW(AMSTREAM_IOC_MAGIC, 0x07, int)
-#define AMSTREAM_IOC_VB_STATUS  _IOR(AMSTREAM_IOC_MAGIC, 0x08, unsigned long)
-#define AMSTREAM_IOC_AB_STATUS  _IOR(AMSTREAM_IOC_MAGIC, 0x09, unsigned long)
-#define AMSTREAM_IOC_SYSINFO    _IOW(AMSTREAM_IOC_MAGIC, 0x0a, int)
-#define AMSTREAM_IOC_ACHANNEL   _IOW(AMSTREAM_IOC_MAGIC, 0x0b, int)
-#define AMSTREAM_IOC_SAMPLERATE _IOW(AMSTREAM_IOC_MAGIC, 0x0c, int)
-#define AMSTREAM_IOC_DATAWIDTH  _IOW(AMSTREAM_IOC_MAGIC, 0x0d, int)
-#define AMSTREAM_IOC_TSTAMP     _IOW(AMSTREAM_IOC_MAGIC, 0x0e, unsigned long)
-#define AMSTREAM_IOC_VDECSTAT   _IOR(AMSTREAM_IOC_MAGIC, 0x0f, unsigned long)
-#define AMSTREAM_IOC_ADECSTAT   _IOR(AMSTREAM_IOC_MAGIC, 0x10, unsigned long)
-#define AMSTREAM_IOC_PORT_INIT  _IO(AMSTREAM_IOC_MAGIC, 0x11)
-#define AMSTREAM_IOC_TRICKMODE  _IOW(AMSTREAM_IOC_MAGIC, 0x12, unsigned long)
-#define AMSTREAM_IOC_AUDIO_INFO  _IOW(AMSTREAM_IOC_MAGIC, 0x13, unsigned long)
-#define AMSTREAM_IOC_TRICK_STAT  _IOR(AMSTREAM_IOC_MAGIC, 0x14, unsigned long)
-#define AMSTREAM_IOC_AUDIO_RESET _IO(AMSTREAM_IOC_MAGIC, 0x15)
-#define AMSTREAM_IOC_SID         _IOW(AMSTREAM_IOC_MAGIC, 0x16, int)
-#define AMSTREAM_IOC_VPAUSE      _IOW(AMSTREAM_IOC_MAGIC, 0x17, int)
-#define AMSTREAM_IOC_AVTHRESH    _IOW(AMSTREAM_IOC_MAGIC, 0x18, int)
-#define AMSTREAM_IOC_SYNCTHRESH  _IOW(AMSTREAM_IOC_MAGIC, 0x19, int)
-#define AMSTREAM_IOC_SUB_RESET   _IOW(AMSTREAM_IOC_MAGIC, 0x1a, int)
-#define AMSTREAM_IOC_SUB_LENGTH  _IOR(AMSTREAM_IOC_MAGIC, 0x1b, unsigned long)
-#define AMSTREAM_IOC_SET_DEC_RESET _IOW(AMSTREAM_IOC_MAGIC, 0x1c, int)
-#define AMSTREAM_IOC_TS_SKIPBYTE _IOW(AMSTREAM_IOC_MAGIC, 0x1d, int)
-#define AMSTREAM_IOC_SUB_TYPE    _IOW(AMSTREAM_IOC_MAGIC, 0x1e, int)
-#define AMSTREAM_IOC_CLEAR_VIDEO    _IOW(AMSTREAM_IOC_MAGIC, 0x1f, int)
-#define AMSTREAM_IOC_APTS             _IOR(AMSTREAM_IOC_MAGIC, 0x40, unsigned long)
-#define AMSTREAM_IOC_VPTS             _IOR(AMSTREAM_IOC_MAGIC, 0x41, unsigned long)
-#define AMSTREAM_IOC_PCRSCR           _IOR(AMSTREAM_IOC_MAGIC, 0x42, unsigned long)
-#define AMSTREAM_IOC_SYNCENABLE      _IOW(AMSTREAM_IOC_MAGIC, 0x43, unsigned long)
-#define AMSTREAM_IOC_GET_SYNC_ADISCON  _IOR(AMSTREAM_IOC_MAGIC, 0x44, unsigned long)
-#define AMSTREAM_IOC_SET_SYNC_ADISCON  _IOW(AMSTREAM_IOC_MAGIC, 0x45, unsigned long)
-#define AMSTREAM_IOC_GET_SYNC_VDISCON  _IOR(AMSTREAM_IOC_MAGIC, 0x46, unsigned long)
-#define AMSTREAM_IOC_SET_SYNC_VDISCON  _IOW(AMSTREAM_IOC_MAGIC, 0x47, unsigned long)
-#define AMSTREAM_IOC_GET_VIDEO_DISABLE  _IOR(AMSTREAM_IOC_MAGIC, 0x48, unsigned long)
-#define AMSTREAM_IOC_SET_VIDEO_DISABLE  _IOW(AMSTREAM_IOC_MAGIC, 0x49, unsigned long)
-#define AMSTREAM_IOC_SET_PCRSCR       _IOW(AMSTREAM_IOC_MAGIC, 0x4a, unsigned long)
-#define AMSTREAM_IOC_GET_VIDEO_AXIS   _IOR(AMSTREAM_IOC_MAGIC, 0x4b, unsigned long)
-#define AMSTREAM_IOC_SET_VIDEO_AXIS   _IOW(AMSTREAM_IOC_MAGIC, 0x4c, unsigned long)
-#define AMSTREAM_IOC_GET_VIDEO_CROP   _IOR(AMSTREAM_IOC_MAGIC, 0x4d, unsigned long)
-#define AMSTREAM_IOC_SET_VIDEO_CROP   _IOW(AMSTREAM_IOC_MAGIC, 0x4e, unsigned long)
-#define AMSTREAM_IOC_SUB_NUM	_IOR(AMSTREAM_IOC_MAGIC, 0x50, unsigned long)
-#define AMSTREAM_IOC_SUB_INFO	_IOR(AMSTREAM_IOC_MAGIC, 0x51, unsigned long)
-#define AMSTREAM_IOC_GET_SCREEN_MODE _IOR(AMSTREAM_IOC_MAGIC, 0x58, int)
-#define AMSTREAM_IOC_SET_SCREEN_MODE _IOW(AMSTREAM_IOC_MAGIC, 0x59, int)
-#define AMSTREAM_IOC_SET_DEMUX  _IOW(AMSTREAM_IOC_MAGIC, 0x90, unsigned long)
-#define AMSTREAM_IOC_GET_SYNC_ADISCON_DIFF  _IOR(AMSTREAM_IOC_MAGIC, 0x83, unsigned long)
-#define AMSTREAM_IOC_GET_SYNC_VDISCON_DIFF  _IOR(AMSTREAM_IOC_MAGIC, 0x84, unsigned long)
-#define AMSTREAM_IOC_SET_SYNC_ADISCON_DIFF  _IOW(AMSTREAM_IOC_MAGIC, 0x85, unsigned long)
-#define AMSTREAM_IOC_SET_SYNC_VDISCON_DIFF  _IOW(AMSTREAM_IOC_MAGIC, 0x86, unsigned long)
-#define AMSTREAM_IOC_GET_FREERUN_MODE  _IOR(AMSTREAM_IOC_MAGIC, 0x87, unsigned long)
-#define AMSTREAM_IOC_SET_FREERUN_MODE  _IOW(AMSTREAM_IOC_MAGIC, 0x88, unsigned long)
-#define AMSTREAM_IOC_SET_VSYNC_UPINT   _IOW(AMSTREAM_IOC_MAGIC, 0x89, unsigned long)
-
-#define AMSTREAM_IOC_SET_VIDEO_DELAY_LIMIT_MS _IOW(AMSTREAM_IOC_MAGIC, 0xa0, unsigned long)
-#define AMSTREAM_IOC_GET_VIDEO_DELAY_LIMIT_MS _IOR(AMSTREAM_IOC_MAGIC, 0xa1, unsigned long)
-#define AMSTREAM_IOC_SET_AUDIO_DELAY_LIMIT_MS _IOW(AMSTREAM_IOC_MAGIC, 0xa2, unsigned long)
-#define AMSTREAM_IOC_GET_AUDIO_DELAY_LIMIT_MS _IOR(AMSTREAM_IOC_MAGIC, 0xa3, unsigned long)
-#define AMSTREAM_IOC_GET_AUDIO_CUR_DELAY_MS _IOR(AMSTREAM_IOC_MAGIC, 0xa4, unsigned long)
-#define AMSTREAM_IOC_GET_VIDEO_CUR_DELAY_MS _IOR(AMSTREAM_IOC_MAGIC, 0xa5, unsigned long)
-#define AMSTREAM_IOC_GET_AUDIO_AVG_BITRATE_BPS _IOR(AMSTREAM_IOC_MAGIC, 0xa6, unsigned long)
-#define AMSTREAM_IOC_GET_VIDEO_AVG_BITRATE_BPS _IOR(AMSTREAM_IOC_MAGIC, 0xa7, unsigned long)
-#define AMSTREAM_IOC_SET_APTS                  _IOW(AMSTREAM_IOC_MAGIC, 0xa8, unsigned long)
-
-#define AMSTREAM_IOC_GET_LAST_CHECKIN_APTS   _IOR(AMSTREAM_IOC_MAGIC, 0xa9, unsigned long)
-#define AMSTREAM_IOC_GET_LAST_CHECKIN_VPTS   _IOR(AMSTREAM_IOC_MAGIC, 0xaa, unsigned long)
-#define AMSTREAM_IOC_GET_LAST_CHECKOUT_APTS  _IOR(AMSTREAM_IOC_MAGIC, 0xab, unsigned long)
-#define AMSTREAM_IOC_GET_LAST_CHECKOUT_VPTS  _IOR(AMSTREAM_IOC_MAGIC, 0xac, unsigned long)
+#define AMSTREAM_IOC_PORT_INIT   _IO((AMSTREAM_IOC_MAGIC), 0x11)
+#define AMSTREAM_IOC_TRICKMODE  _IOW((AMSTREAM_IOC_MAGIC), 0x12, int)
+
+#define AMSTREAM_IOC_AUDIO_INFO _IOW((AMSTREAM_IOC_MAGIC), 0x13, int)
+#define AMSTREAM_IOC_TRICK_STAT  _IOR((AMSTREAM_IOC_MAGIC), 0x14, int)
+#define AMSTREAM_IOC_AUDIO_RESET _IO((AMSTREAM_IOC_MAGIC), 0x15)
+#define AMSTREAM_IOC_SID         _IOW((AMSTREAM_IOC_MAGIC), 0x16, int)
+#define AMSTREAM_IOC_VPAUSE      _IOW((AMSTREAM_IOC_MAGIC), 0x17, int)
+#define AMSTREAM_IOC_AVTHRESH   _IOW((AMSTREAM_IOC_MAGIC), 0x18, int)
+#define AMSTREAM_IOC_SYNCTHRESH _IOW((AMSTREAM_IOC_MAGIC), 0x19, int)
+#define AMSTREAM_IOC_SUB_RESET   _IOW((AMSTREAM_IOC_MAGIC), 0x1a, int)
+#define AMSTREAM_IOC_SUB_LENGTH  _IOR((AMSTREAM_IOC_MAGIC), 0x1b, int)
+#define AMSTREAM_IOC_SET_DEC_RESET _IOW((AMSTREAM_IOC_MAGIC), 0x1c, int)
+#define AMSTREAM_IOC_TS_SKIPBYTE _IOW((AMSTREAM_IOC_MAGIC), 0x1d, int)
+#define AMSTREAM_IOC_SUB_TYPE    _IOW((AMSTREAM_IOC_MAGIC), 0x1e, int)
+#define AMSTREAM_IOC_CLEAR_VIDEO _IOW((AMSTREAM_IOC_MAGIC), 0x1f, int)
+
+#define AMSTREAM_IOC_APTS             _IOR((AMSTREAM_IOC_MAGIC), 0x40, int)
+#define AMSTREAM_IOC_VPTS             _IOR((AMSTREAM_IOC_MAGIC), 0x41, int)
+#define AMSTREAM_IOC_PCRSCR           _IOR((AMSTREAM_IOC_MAGIC), 0x42, int)
+#define AMSTREAM_IOC_SYNCENABLE      _IOW((AMSTREAM_IOC_MAGIC), 0x43, int)
+#define AMSTREAM_IOC_GET_SYNC_ADISCON  _IOR((AMSTREAM_IOC_MAGIC), 0x44, int)
+#define AMSTREAM_IOC_SET_SYNC_ADISCON  _IOW((AMSTREAM_IOC_MAGIC), 0x45, int)
+#define AMSTREAM_IOC_GET_SYNC_VDISCON  _IOR((AMSTREAM_IOC_MAGIC), 0x46, int)
+#define AMSTREAM_IOC_SET_SYNC_VDISCON  _IOW((AMSTREAM_IOC_MAGIC), 0x47, int)
+#define AMSTREAM_IOC_GET_VIDEO_DISABLE  _IOR((AMSTREAM_IOC_MAGIC), 0x48, int)
+#define AMSTREAM_IOC_SET_VIDEO_DISABLE  _IOW((AMSTREAM_IOC_MAGIC), 0x49, int)
+#define AMSTREAM_IOC_SET_PCRSCR       _IOW((AMSTREAM_IOC_MAGIC), 0x4a, int)
+#define AMSTREAM_IOC_GET_VIDEO_AXIS   _IOR((AMSTREAM_IOC_MAGIC), 0x4b, int)
+#define AMSTREAM_IOC_SET_VIDEO_AXIS   _IOW((AMSTREAM_IOC_MAGIC), 0x4c, int)
+#define AMSTREAM_IOC_GET_VIDEO_CROP   _IOR((AMSTREAM_IOC_MAGIC), 0x4d, int)
+#define AMSTREAM_IOC_SET_VIDEO_CROP   _IOW((AMSTREAM_IOC_MAGIC), 0x4e, int)
+#define AMSTREAM_IOC_PCRID        _IOW((AMSTREAM_IOC_MAGIC), 0x4f, int)
+
+/* VPP.3D IOCTL command list^M */
+#define  AMSTREAM_IOC_SET_3D_TYPE  _IOW((AMSTREAM_IOC_MAGIC), 0x3c, unsigned int)
+#define  AMSTREAM_IOC_GET_3D_TYPE  _IOW((AMSTREAM_IOC_MAGIC), 0x3d, unsigned int)
+
+#define AMSTREAM_IOC_SUB_NUM    _IOR((AMSTREAM_IOC_MAGIC), 0x50, int)
+#define AMSTREAM_IOC_SUB_INFO   _IOR((AMSTREAM_IOC_MAGIC), 0x51, int)
+#define AMSTREAM_IOC_GET_BLACKOUT_POLICY   _IOR((AMSTREAM_IOC_MAGIC), 0x52, int)
+#define AMSTREAM_IOC_SET_BLACKOUT_POLICY   _IOW((AMSTREAM_IOC_MAGIC), 0x53, int)
+#define AMSTREAM_IOC_UD_LENGTH _IOR((AMSTREAM_IOC_MAGIC), 0x54, int)
+#define AMSTREAM_IOC_UD_POC _IOR((AMSTREAM_IOC_MAGIC), 0x55, int)
+#define AMSTREAM_IOC_GET_SCREEN_MODE _IOR((AMSTREAM_IOC_MAGIC), 0x58, int)
+#define AMSTREAM_IOC_SET_SCREEN_MODE _IOW((AMSTREAM_IOC_MAGIC), 0x59, int)
+#define AMSTREAM_IOC_GET_VIDEO_DISCONTINUE_REPORT _IOR((AMSTREAM_IOC_MAGIC), 0x5a, int)
+#define AMSTREAM_IOC_SET_VIDEO_DISCONTINUE_REPORT _IOW((AMSTREAM_IOC_MAGIC), 0x5b, int)
+#define AMSTREAM_IOC_VF_STATUS  _IOR((AMSTREAM_IOC_MAGIC), 0x60, int)
+#define AMSTREAM_IOC_CLEAR_VBUF _IO((AMSTREAM_IOC_MAGIC), 0x80)
+
+#define AMSTREAM_IOC_APTS_LOOKUP    _IOR((AMSTREAM_IOC_MAGIC), 0x81, int)
+#define GET_FIRST_APTS_FLAG    _IOR((AMSTREAM_IOC_MAGIC), 0x82, int)
+#define AMSTREAM_IOC_GET_SYNC_ADISCON_DIFF  _IOR((AMSTREAM_IOC_MAGIC), 0x83, int)
+#define AMSTREAM_IOC_GET_SYNC_VDISCON_DIFF  _IOR((AMSTREAM_IOC_MAGIC), 0x84, int)
+#define AMSTREAM_IOC_SET_SYNC_ADISCON_DIFF  _IOW((AMSTREAM_IOC_MAGIC), 0x85, int)
+#define AMSTREAM_IOC_SET_SYNC_VDISCON_DIFF  _IOW((AMSTREAM_IOC_MAGIC), 0x86, int)
+#define AMSTREAM_IOC_GET_FREERUN_MODE  _IOR((AMSTREAM_IOC_MAGIC), 0x87, int)
+#define AMSTREAM_IOC_SET_FREERUN_MODE  _IOW((AMSTREAM_IOC_MAGIC), 0x88, int)
+#define AMSTREAM_IOC_SET_VSYNC_UPINT   _IOW((AMSTREAM_IOC_MAGIC), 0x89, int)
+#define AMSTREAM_IOC_GET_VSYNC_SLOW_FACTOR   _IOW((AMSTREAM_IOC_MAGIC), 0x8a, int)
+#define AMSTREAM_IOC_SET_VSYNC_SLOW_FACTOR   _IOW((AMSTREAM_IOC_MAGIC), 0x8b, int)
+#define AMSTREAM_IOC_SET_DEMUX  _IOW((AMSTREAM_IOC_MAGIC), 0x90, int)
+#define AMSTREAM_IOC_SET_DRMMODE _IOW((AMSTREAM_IOC_MAGIC), 0x91, int)
+#define AMSTREAM_IOC_TSTAMP_uS64 _IOW((AMSTREAM_IOC_MAGIC), 0x95, int)
+
+#define AMSTREAM_IOC_SET_VIDEO_DELAY_LIMIT_MS _IOW((AMSTREAM_IOC_MAGIC), 0xa0, int)
+#define AMSTREAM_IOC_GET_VIDEO_DELAY_LIMIT_MS _IOR((AMSTREAM_IOC_MAGIC), 0xa1, int)
+#define AMSTREAM_IOC_SET_AUDIO_DELAY_LIMIT_MS _IOW((AMSTREAM_IOC_MAGIC), 0xa2, int)
+#define AMSTREAM_IOC_GET_AUDIO_DELAY_LIMIT_MS _IOR((AMSTREAM_IOC_MAGIC), 0xa3, int)
+#define AMSTREAM_IOC_GET_AUDIO_CUR_DELAY_MS _IOR((AMSTREAM_IOC_MAGIC), 0xa4, int)
+#define AMSTREAM_IOC_GET_VIDEO_CUR_DELAY_MS _IOR((AMSTREAM_IOC_MAGIC), 0xa5, int)
+#define AMSTREAM_IOC_GET_AUDIO_AVG_BITRATE_BPS _IOR((AMSTREAM_IOC_MAGIC), 0xa6, int)
+#define AMSTREAM_IOC_GET_VIDEO_AVG_BITRATE_BPS _IOR((AMSTREAM_IOC_MAGIC), 0xa7, int)
+#define AMSTREAM_IOC_SET_APTS  _IOW((AMSTREAM_IOC_MAGIC), 0xa8, int)
+#define AMSTREAM_IOC_GET_LAST_CHECKIN_APTS _IOR((AMSTREAM_IOC_MAGIC), 0xa9, int)
+#define AMSTREAM_IOC_GET_LAST_CHECKIN_VPTS _IOR((AMSTREAM_IOC_MAGIC), 0xaa, int)
+#define AMSTREAM_IOC_GET_LAST_CHECKOUT_APTS _IOR((AMSTREAM_IOC_MAGIC), 0xab, int)
+#define AMSTREAM_IOC_GET_LAST_CHECKOUT_VPTS _IOR((AMSTREAM_IOC_MAGIC), 0xac, int)
 
 #define AMSTREAM_IOC_SET_PLAYRATE    _IOW(AMSTREAM_IOC_MAGIC, 0xb0, unsigned long)
 
+/* subtitle.c get/set subtitle info */
+#define AMSTREAM_IOC_GET_SUBTITLE_INFO _IOR((AMSTREAM_IOC_MAGIC), 0xad, int)
+#define AMSTREAM_IOC_SET_SUBTITLE_INFO _IOW((AMSTREAM_IOC_MAGIC), 0xae, int)
+#define AMSTREAM_IOC_SET_OMX_VPTS _IOW((AMSTREAM_IOC_MAGIC), 0xaf, int)
+#define AMSTREAM_IOC_GET_OMX_VPTS _IOW((AMSTREAM_IOC_MAGIC), 0xb0, int)
+
+#define AMSTREAM_IOC_GET_TRICK_VPTS _IOR((AMSTREAM_IOC_MAGIC), 0xf0, int)
+#define AMSTREAM_IOC_DISABLE_SLOW_SYNC _IOW((AMSTREAM_IOC_MAGIC), 0xf1, int)
+
+#define AMSTREAM_IOC_GET_AUDIO_CHECKIN_BITRATE_BPS _IOR(AMSTREAM_IOC_MAGIC, 0xf2, int)
+#define AMSTREAM_IOC_GET_VIDEO_CHECKIN_BITRATE_BPS _IOR(AMSTREAM_IOC_MAGIC, 0xf3, int)
+
+#define AMSTREAM_IOC_GET_VERSION _IOR((AMSTREAM_IOC_MAGIC), 0xc0, int)
+#define AMSTREAM_IOC_GET _IOWR((AMSTREAM_IOC_MAGIC), 0xc1, struct am_ioctl_parm)
+#define AMSTREAM_IOC_SET _IOW((AMSTREAM_IOC_MAGIC), 0xc2, struct am_ioctl_parm)
+#define AMSTREAM_IOC_GET_EX _IOWR((AMSTREAM_IOC_MAGIC), 0xc3, struct am_ioctl_parm_ex)
+#define AMSTREAM_IOC_SET_EX _IOW((AMSTREAM_IOC_MAGIC), 0xc4, struct am_ioctl_parm_ex)
+#define AMSTREAM_IOC_GET_PTR _IOWR((AMSTREAM_IOC_MAGIC), 0xc5, struct am_ioctl_parm_ptr)
+#define AMSTREAM_IOC_SET_PTR _IOW((AMSTREAM_IOC_MAGIC), 0xc6, struct am_ioctl_parm_ptr)
+
 #define AMAUDIO_IOC_MAGIC  'A'
 #define AMAUDIO_IOC_SET_RESAMPLE_ENA        _IOW(AMAUDIO_IOC_MAGIC, 0x19, unsigned long)
 #define AMAUDIO_IOC_GET_RESAMPLE_ENA        _IOR(AMAUDIO_IOC_MAGIC, 0x1a, unsigned long)
@@ -136,9 +180,6 @@
 #define AMAUDIO_IOC_GET_RESAMPLE_TYPE       _IOR(AMAUDIO_IOC_MAGIC, 0x1c, unsigned long)
 #define AMAUDIO_IOC_SET_RESAMPLE_DELTA      _IOW(AMAUDIO_IOC_MAGIC, 0x1d, unsigned long)
 
-#define AMSTREAM_IOC_SET_DRMMODE _IOW(AMSTREAM_IOC_MAGIC, 0x91, unsigned long)
-#define AMSTREAM_IOC_GET_SCR_STATE _IOR(AMSTREAM_IOC_MAGIC, 0x92, unsigned long)
-
 struct buf_status {
     int size;
     int data_len;
@@ -147,7 +188,25 @@ struct buf_status {
     unsigned int write_pointer;
 };
 
+/*struct vdec_status.status*/
+#define STAT_TIMER_INIT     0x01
+#define STAT_MC_LOAD        0x02
+#define STAT_ISR_REG        0x04
+#define STAT_VF_HOOK        0x08
+#define STAT_TIMER_ARM      0x10
+#define STAT_VDEC_RUN       0x20
+//-/*struct vdec_status.status on error*/
 
+#define PARSER_FATAL_ERROR              (0x10<<16)
+#define DECODER_ERROR_VLC_DECODE_TBL    (0x20<<16)
+#define PARSER_ERROR_WRONG_HEAD_VER     (0x40<<16)
+#define PARSER_ERROR_WRONG_PACKAGE_SIZE (0x80<<16)
+#define DECODER_FATAL_ERROR_SIZE_OVERFLOW     (0x100<<16)
+#define DECODER_FATAL_ERROR_UNKNOW             (0x200<<16)
+#define DECODER_FATAL_ERROR_NO_MEM		(0x400<<16)
+
+
+#define DECODER_ERROR_MASK  (0xffff<<16)
 struct vdec_status {
     unsigned int width;
     unsigned int height;
@@ -179,6 +238,177 @@ struct am_io_param {
         struct adec_status astatus;
     };
 };
+struct subtitle_info {
+
+	unsigned char id;
+
+	unsigned char width;
+
+	unsigned char height;
+
+	unsigned char type;
+};
+
+struct userdata_poc_info_t {
+
+	unsigned int poc_info;
+
+	unsigned int poc_number;
+};
+
+/*******************************************************************
+* 0x100~~0x1FF : set cmd
+* 0x200~~0x2FF : set ex cmd
+* 0x300~~0x3FF : set ptr cmd
+* 0x400~~0x7FF : set reserved cmd
+* 0x800~~0x8FF : get cmd
+* 0x900~~0x9FF : get ex cmd
+* 0xA00~~0xAFF : get ptr cmd
+* 0xBFF~~0xFFF : get reserved cmd
+* 0xX00~~0xX5F : amstream cmd(X: cmd type)
+* 0xX60~~0xXAF : video cmd(X: cmd type)
+* 0xXAF~~0xXFF : reserved cmd(X: cmd type)
+*******************************************************************/
+/*  amstream set cmd */
+#define AMSTREAM_SET_VB_START 0x101
+#define AMSTREAM_SET_VB_SIZE 0x102
+#define AMSTREAM_SET_AB_START 0x103
+#define AMSTREAM_SET_AB_SIZE 0x104
+#define AMSTREAM_SET_VFORMAT 0x105
+#define AMSTREAM_SET_AFORMAT 0x106
+#define AMSTREAM_SET_VID 0x107
+#define AMSTREAM_SET_AID 0x108
+#define AMSTREAM_SET_SID 0x109
+#define AMSTREAM_SET_PCRID 0x10A
+#define AMSTREAM_SET_ACHANNEL 0x10B
+#define AMSTREAM_SET_SAMPLERATE 0x10C
+#define AMSTREAM_SET_DATAWIDTH 0x10D
+#define AMSTREAM_SET_TSTAMP 0x10E
+#define AMSTREAM_SET_TSTAMP_US64 0x10F
+#define AMSTREAM_SET_APTS 0x110
+#define AMSTREAM_PORT_INIT 0x111
+#define AMSTREAM_SET_TRICKMODE 0x112 /* amstream,video */
+#define AMSTREAM_AUDIO_RESET 0x013
+#define AMSTREAM_SUB_RESET 0x114
+#define AMSTREAM_DEC_RESET 0x115
+#define AMSTREAM_SET_TS_SKIPBYTE 0x116
+#define AMSTREAM_SET_SUB_TYPE 0x117
+#define AMSTREAM_SET_PCRSCR 0x118
+#define AMSTREAM_SET_DEMUX 0x119
+#define AMSTREAM_SET_VIDEO_DELAY_LIMIT_MS 0x11A
+#define AMSTREAM_SET_AUDIO_DELAY_LIMIT_MS 0x11B
+#define AMSTREAM_SET_DRMMODE 0x11C
+/*  video set   cmd */
+#define AMSTREAM_SET_OMX_VPTS 0x160
+#define AMSTREAM_SET_VPAUSE 0x161
+#define AMSTREAM_SET_AVTHRESH 0x162
+#define AMSTREAM_SET_SYNCTHRESH 0x163
+#define AMSTREAM_SET_SYNCENABLE 0x164
+#define AMSTREAM_SET_SYNC_ADISCON 0x165
+#define AMSTREAM_SET_SYNC_VDISCON 0x166
+#define AMSTREAM_SET_SYNC_ADISCON_DIFF 0x167
+#define AMSTREAM_SET_SYNC_VDISCON_DIFF 0x168
+#define AMSTREAM_SET_VIDEO_DISABLE 0x169
+#define AMSTREAM_SET_VIDEO_DISCONTINUE_REPORT 0x16A
+#define AMSTREAM_SET_SCREEN_MODE 0x16B
+#define AMSTREAM_SET_BLACKOUT_POLICY 0x16C
+#define AMSTREAM_CLEAR_VBUF 0x16D
+#define AMSTREAM_SET_CLEAR_VIDEO 0x16E
+#define AMSTREAM_SET_FREERUN_MODE 0x16F
+#define AMSTREAM_SET_DISABLE_SLOW_SYNC 0x170
+#define AMSTREAM_SET_3D_TYPE 0x171
+#define AMSTREAM_SET_VSYNC_UPINT 0x172
+#define AMSTREAM_SET_VSYNC_SLOW_FACTOR 0x173
+/*  video set ex cmd */
+#define AMSTREAM_SET_EX_VIDEO_AXIS 0x260
+#define AMSTREAM_SET_EX_VIDEO_CROP 0x261
+/*  amstream set ptr cmd */
+#define AMSTREAM_SET_PTR_AUDIO_INFO 0x300
+
+/*  amstream get cmd */
+#define AMSTREAM_GET_SUB_LENGTH 0x800
+#define AMSTREAM_GET_UD_LENGTH 0x801
+#define AMSTREAM_GET_APTS_LOOKUP 0x802
+#define AMSTREAM_GET_FIRST_APTS_FLAG 0x803
+#define AMSTREAM_GET_APTS 0x804
+#define AMSTREAM_GET_VPTS 0x805
+#define AMSTREAM_GET_PCRSCR 0x806
+#define AMSTREAM_GET_LAST_CHECKIN_APTS 0x807
+#define AMSTREAM_GET_LAST_CHECKIN_VPTS 0x808
+#define AMSTREAM_GET_LAST_CHECKOUT_APTS 0x809
+#define AMSTREAM_GET_LAST_CHECKOUT_VPTS 0x80A
+#define AMSTREAM_GET_SUB_NUM 0x80B
+#define AMSTREAM_GET_VIDEO_DELAY_LIMIT_MS 0x80C
+#define AMSTREAM_GET_AUDIO_DELAY_LIMIT_MS 0x80D
+#define AMSTREAM_GET_AUDIO_CUR_DELAY_MS 0x80E
+#define AMSTREAM_GET_VIDEO_CUR_DELAY_MS 0x80F
+#define AMSTREAM_GET_AUDIO_AVG_BITRATE_BPS 0x810
+#define AMSTREAM_GET_VIDEO_AVG_BITRATE_BPS 0x811
+/*  video get cmd */
+#define AMSTREAM_GET_OMX_VPTS 0x860
+#define AMSTREAM_GET_TRICK_STAT 0x861
+#define AMSTREAM_GET_TRICK_VPTS 0x862
+#define AMSTREAM_GET_SYNC_ADISCON 0x863
+#define AMSTREAM_GET_SYNC_VDISCON 0x864
+#define AMSTREAM_GET_SYNC_ADISCON_DIFF 0x865
+#define AMSTREAM_GET_SYNC_VDISCON_DIFF 0x866
+#define AMSTREAM_GET_VIDEO_DISABLE 0x867
+#define AMSTREAM_GET_VIDEO_DISCONTINUE_REPORT 0x868
+#define AMSTREAM_GET_SCREEN_MODE 0x869
+#define AMSTREAM_GET_BLACKOUT_POLICY 0x86A
+#define AMSTREAM_GET_FREERUN_MODE 0x86B
+#define AMSTREAM_GET_3D_TYPE 0x86C
+#define AMSTREAM_GET_VSYNC_SLOW_FACTOR 0x86D
+/*  amstream get ex cmd */
+#define AMSTREAM_GET_EX_VB_STATUS 0x900
+#define AMSTREAM_GET_EX_AB_STATUS 0x901
+#define AMSTREAM_GET_EX_VDECSTAT 0x902
+#define AMSTREAM_GET_EX_ADECSTAT 0x903
+#define AMSTREAM_GET_EX_UD_POC 0x904
+/*  video get ex cmd */
+#define AMSTREAM_GET_EX_VF_STATUS 0x960
+#define AMSTREAM_GET_EX_VIDEO_AXIS 0x961
+#define AMSTREAM_GET_EX_VIDEO_CROP 0x962
+/*  amstream get ptr cmd */
+#define AMSTREAM_GET_PTR_SUB_INFO 0xA00
+
+struct am_ioctl_parm {
+    union {
+        unsigned int data_32;
+        unsigned long long data_64;
+        vformat_t data_vformat;
+        aformat_t data_aformat;
+        char data[8];
+    };
+    unsigned int cmd;
+    char reserved[4];
+};
+
+struct am_ioctl_parm_ex {
+    union {
+        struct buf_status status;
+        struct vdec_status vstatus;
+        struct adec_status astatus;
+
+        struct userdata_poc_info_t data_userdata_info;
+        char data[24];
+
+    };
+    unsigned int cmd;
+    char reserved[4];
+};
+
+struct am_ioctl_parm_ptr {
+    union {
+        struct audio_info *pdata_audio_info;
+        struct subtitle_info *pdata_sub_info;
+        void *pointer;
+        char data[8];
+    };
+    unsigned int cmd;
+    char reserved[4];
+};
+
 void set_vdec_func(int (*vdec_func)(struct vdec_status *));
 void set_adec_func(int (*adec_func)(struct adec_status *));
 
diff --git a/amcodec/include/amports/vformat.h b/amcodec/include/amports/vformat.h
index c2f16ca..300d87d 100755
--- a/amcodec/include/amports/vformat.h
+++ b/amcodec/include/amports/vformat.h
@@ -51,6 +51,7 @@ typedef enum {
     VIDEO_DEC_FORMAT_AVS,
     VIDEO_DEC_FORMAT_H264_4K2K,
     VIDEO_DEC_FORMAT_HEVC,
+    VIDEO_DEC_FORMAT_VP9 ,
     VIDEO_DEC_FORMAT_MAX
 } vdec_type_t;
 
@@ -68,8 +69,13 @@ typedef enum {
     VFORMAT_H264MVC,
     VFORMAT_H264_4K2K,
     VFORMAT_HEVC,
-    VFORMAT_UNSUPPORT,
-    VFORMAT_MAX
+    VFORMAT_H264_ENC,
+    VFORMAT_JPEG_ENC,
+    VFORMAT_VP9,
+
+/*add new here before.*/
+    VFORMAT_MAX,
+    VFORMAT_UNSUPPORT = VFORMAT_MAX
 } vformat_t;
 
 #define IS_VFMT_VALID(vfmt)	((vfmt > VFORMAT_UNKNOWN) && (vfmt < VFORMAT_MAX))
@@ -103,7 +109,6 @@ typedef enum {
 #define CODEC_TAG_mp4v      (0x7634706d)
 #define CODEC_TAG_AVC1      (0x31435641)
 #define CODEC_TAG_avc1      (0x31637661)
-#define CODEC_TAG_hvc1      (0x31637668)
 #define CODEC_TAG_H264      (0x34363248)
 #define CODEC_TAG_h264      (0x34363268)
 #define CODEC_TAG_HEVC      (0x43564548)
@@ -120,5 +125,7 @@ typedef enum {
 #define CODEC_TAG_WMVA      (0x41564d57)
 #define CODEC_TAG_FMP4      (0x34504d46)
 #define CODEC_TAG_FVFW      (0x57465646)
+#define CODEC_TAG_VC_1      (0x312d4356)
+#define CODEC_TAG_vc_1      (0x312d6376)
 
 #endif /* VFORMAT_H */
diff --git a/amcodec/include/codec.h b/amcodec/include/codec.h
index ddaa225..13b44e2 100755
--- a/amcodec/include/codec.h
+++ b/amcodec/include/codec.h
@@ -14,7 +14,9 @@
 
 #include "codec_type.h"
 #include "codec_error.h"
-
+#ifdef __cplusplus
+extern "C" {
+#endif
 int codec_init(codec_para_t *);
 int codec_close(codec_para_t *);
 void codec_audio_basic_init(void);
@@ -61,6 +63,8 @@ int codec_set_mute(codec_para_t *p, int mute);
 int codec_get_volume_range(codec_para_t *, int *min, int *max);
 int codec_set_volume(codec_para_t *, float val);
 int codec_get_volume(codec_para_t *, float *val);
+int codec_set_volume_ease(codec_para_t *, float val, unsigned int duration, int method);
+int codec_get_volume_ease(codec_para_t *, float *val, unsigned int *duration);
 int codec_set_lrvolume(codec_para_t *, float lvol,float rvol);
 int codec_get_lrvolume(codec_para_t *, float *lvol,float* rvol);
 int codec_get_mutesta(codec_para_t *);
@@ -115,6 +119,8 @@ int codec_get_audio_cur_bitrate(codec_para_t *pcodec,int *bitrate);
 
 int codec_set_vsync_upint(codec_para_t *pcodec, unsigned int mode);
 
+int codec_set_drmmode(codec_para_t *pcodec, unsigned int mode);
+
 int codec_get_last_checkout_apts(codec_para_t* pcodec, unsigned long *apts);
 int codec_get_last_checkin_apts(codec_para_t* pcodec, unsigned long *apts);
 /*add for gstreamer fast/slow forward*/
@@ -123,4 +129,7 @@ int codec_set_video_playrate(codec_para_t* pcodec, int rate);
 int dummy_codec_set_mute(int mute);
 int dummy_codec_set_volume(int vol);
 int dummy_codec_get_volume(int *vol);
+#ifdef __cplusplus
+}
+#endif
 #endif
diff --git a/amcodec/include/codec_type.h b/amcodec/include/codec_type.h
index 993bb5b..0fb5654 100755
--- a/amcodec/include/codec_type.h
+++ b/amcodec/include/codec_type.h
@@ -95,6 +95,7 @@ unsigned int noblock:
     int SessionID;
 	int dspdec_not_supported;//check some profile that audiodsp decoder can not support,we switch to arm decoder
 	int switch_audio_flag;		//<switch audio flag switching(1) else(0)
+    int automute_flag;
 } codec_para_t;
 
 typedef struct 
@@ -125,6 +126,8 @@ typedef struct {
 	int SessionID;
 	int dspdec_not_supported;//check some profile that audiodsp decoder can not support,we switch to arm decoder	
 	int droppcm_flag;				// drop pcm flag, if switch audio (1)
+    int automute;
+    unsigned int has_video;
 } arm_audio_info;
 
 //audio decoder type, default arc
-- 
1.9.1

